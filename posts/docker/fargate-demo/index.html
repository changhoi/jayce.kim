<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>컨테이너 서버리스 Fargate 배포하기 - Changhoi Kim</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="white"><meta name="application-name" content="Changhoi Kim"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="msapplication-TileColor" content="white"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Changhoi Kim"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="최근 개발 중인 앱이, 이제 서비스 준비를 앞 두고 있는데, 개발자가 부족하므로, 운영 환경에 최대한 얽메이지 않고 싶다는 욕구에 의해 컨테이너 서버리스인 Fargate 배포에 눈을 돌리게 되었다. 이 글에서는 AWS ECS를 동작하기 위한 가장 기본적인 개념과 Fargate가 무엇인지 간단하게 설명한 다음 사이드 프로젝트로 진행 중이던 프로젝트를 Farg"><meta property="og:type" content="blog"><meta property="og:title" content="컨테이너 서버리스 Fargate 배포하기"><meta property="og:url" content="https://changhoi.kim/posts/docker/fargate-demo/"><meta property="og:site_name" content="Changhoi Kim"><meta property="og:description" content="최근 개발 중인 앱이, 이제 서비스 준비를 앞 두고 있는데, 개발자가 부족하므로, 운영 환경에 최대한 얽메이지 않고 싶다는 욕구에 의해 컨테이너 서버리스인 Fargate 배포에 눈을 돌리게 되었다. 이 글에서는 AWS ECS를 동작하기 위한 가장 기본적인 개념과 Fargate가 무엇인지 간단하게 설명한 다음 사이드 프로젝트로 진행 중이던 프로젝트를 Farg"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://cdn-images-1.medium.com/max/1600/1*YRdbz-SNDxCTnyPGJU347Q.jpeg"><meta property="article:published_time" content="2020-02-21T15:00:00.000Z"><meta property="article:modified_time" content="2020-02-21T15:00:00.000Z"><meta property="article:author" content="changhoi"><meta property="article:tag" content="docker"><meta property="article:tag" content="serverless"><meta property="article:tag" content="aws"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn-images-1.medium.com/max/1600/1*YRdbz-SNDxCTnyPGJU347Q.jpeg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://changhoi.kim/posts/docker/fargate-demo/"},"headline":"컨테이너 서버리스 Fargate 배포하기","image":[],"datePublished":"2020-02-21T15:00:00.000Z","dateModified":"2020-02-21T15:00:00.000Z","author":{"@type":"Person","name":"changhoi"},"publisher":{"@type":"Organization","name":"Changhoi Kim","logo":{"@type":"ImageObject","url":"https://changhoi.kim/img/logo.jpg"}},"description":"최근 개발 중인 앱이, 이제 서비스 준비를 앞 두고 있는데, 개발자가 부족하므로, 운영 환경에 최대한 얽메이지 않고 싶다는 욕구에 의해 컨테이너 서버리스인 Fargate 배포에 눈을 돌리게 되었다. 이 글에서는 AWS ECS를 동작하기 위한 가장 기본적인 개념과 Fargate가 무엇인지 간단하게 설명한 다음 사이드 프로젝트로 진행 중이던 프로젝트를 Farg"}</script><link rel="canonical" href="https://changhoi.kim/posts/docker/fargate-demo/"><link rel="alternate" href="/rss2.xml" title="Changhoi Kim" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-QBSLW6WTZW" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-QBSLW6WTZW');</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.jpg" alt="Changhoi Kim" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://cdn-images-1.medium.com/max/1600/1*YRdbz-SNDxCTnyPGJU347Q.jpeg" alt="컨테이너 서버리스 Fargate 배포하기"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-02-21T15:00:00.000Z" title="2/22/2020, 12:00:00 AM">2020-02-22</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2020-02-21T15:00:00.000Z" title="2/22/2020, 12:00:00 AM">2020-02-22</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/docker/">docker</a></span><span class="level-item">38분안에 읽기 (약 5737 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile">컨테이너 서버리스 Fargate 배포하기</h1><div class="content"><p>최근 개발 중인 앱이, 이제 서비스 준비를 앞 두고 있는데, 개발자가 부족하므로, 운영 환경에 최대한 얽메이지 않고 싶다는 욕구에 의해 컨테이너 서버리스인 Fargate 배포에 눈을 돌리게 되었다. 이 글에서는 AWS ECS를 동작하기 위한 가장 기본적인 개념과 Fargate가 무엇인지 간단하게 설명한 다음 사이드 프로젝트로 진행 중이던 프로젝트를 Fargate 위에 띄우는 것까지 해볼 계획이다.</p>
<span id="more"></span>

<p>우선 Fargate가 뭔지, AWS에서 뭐라고 소개하는지 살펴보자. Fargate는 ECS의 서버리스 서비스이다. 공식적인 소개로는, 아래와 같이 작성되어있다.</p>
<blockquote>
<p>AWS Fargate는 컨테이너에 적합한 서버리스 컴퓨팅 엔진으로, Amazon Elastic Container Service(ECS) 및 Amazon Elastic Kubernetes Service(EKS)에서 모두 작동합니다.<br>Fargate는 애플리케이션을 빌드하는 데 보다 쉽게 초점을 맞출 수 있도록 해 줍니다.<br>Fargate에서는 서버를 프로비저닝하고 관리할 필요가 없어 애플리케이션별로 리소스를 지정하고 관련 비용을 지불할 수 있으며, 계획적으로 애플리케이션을 격리함으로써 보안 성능을 향상시킬 수 있습니다.</p>
</blockquote>
<p>운영 환경을 직접 관리해야 하는 경우 보다는 당연히 애플리케이션에 집중할 수 있는 장점이 있다. ECS를 기반으로 하고 있기 때문에 ECS에 대한 개념 부분을 먼저 확인해보자. ECS에 대한 내용은 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.44bits.io/ko/post/container-orchestration-101-with-docker-and-aws-elastic-container-service#%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0cluster%EC%99%80-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4cluster-instance">44bits</a>의 글에서 가져온 내용들이 많다. 나에게 필요한 부분들만 선별해 요약했지만, 자세한 내용을 읽고 싶은 사람에게 꼭 추천한다. (아주 잘 정리 되어있음)</p>
<h2 id="클러스터와-컨테이너-인스턴스"><a href="#클러스터와-컨테이너-인스턴스" class="headerlink" title="클러스터와 컨테이너 인스턴스"></a>클러스터와 컨테이너 인스턴스</h2><p>ECS의 가장 기본적인 단위는 클러스터이다. 클러스터는 도커 컨테이너를 실행할 수 있는 가상의 공간이다. 클러스터는 프로젝트나 컨테이너의 성격에 따라 나눠질 수 있다. 클러스터는 컴퓨팅 자원을 포함하고 있지 않은 논리적, 가상적인(즉, 실제 컴퓨팅 자원이 필요하지 않다.) 단위이다. 이후에 EC2에 <code>ecs-client</code>라는 컨테이너 인스턴스의 자원을 모니터링하고, 관리하고, 클러스터로 요청된 컨테이너들을 적절하게 실행하는 역할을 하는 서비스를 실행해서 특정 클러스터에 연결할 수 있다. 이렇게 클러스터에 연결 된 EC2 인스턴스를 컨테이너 인스턴스라고 한다. (Fargate에서는 이처럼 관리를 담당하는 컨테이너가 필요하지 않게 된다.)</p>
<h2 id="Task-Task-definition"><a href="#Task-Task-definition" class="headerlink" title="Task &amp; Task definition"></a>Task &amp; Task definition</h2><p>ECS에서 컨테이너를 실행하는 최소 단위는 <code>Task</code>(태스크)이다. <code>Task</code>는 하나 이상의 컨테이너로 구성된다. 하나의 <code>Task</code>로 실행되는 컨테이너들은 모두 같은 컨테이너 인스턴스에서 실행되는 것이 보장된다.</p>
<p><code>Task</code>를 실행하려면 <code>Task definition</code>(태스크 디피니션)이 필요하다. <code>Task</code>를 통해 컨테이너를 실행하려면 여러 설정이 필요한데, 이러한 설정들을 미리 하나의 집합 단위로 정의해 놓고 사용하는 것이다. 이러한 집합 단위를 <code>Task definition</code> 이라고 한다. 한 번 <code>Task definition</code>을 설정해 주면, 그것을 기반으로 특정 설정을 변경할 수 있다. 이런식으로 변경된 내용들은 모두 리비전으로 저장된다. (리비전이 뭔지 아래 간단하게 언급하게 된다.)</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>클러스터에는 두 가지 방식으로 태스크를 실행할 수 있다. 먼저 첫 번째 방식은 <code>Task deifinition</code>을 직접 사용해 태스크를 실행하는 것이다. 이런 식으로 실행된 태스크는 실행 이후 관리되지 않는다. 만약 일회성 프로그램의 경우는 명령 이후 바로 실행된 다음 종료되고, 데몬 프로세스는 프로세스를 종료할 때까지 컨테이너를 남겨둔다.</p>
<p>다른 방식으로는 <code>Service</code>를 정의하는 것이다. 간단하게 <code>Service</code>는 클러스터 내의 태스크를 스케줄링 하는 용도로 사용된다. 만약 EC2를 사용해서 프로세스를 배치하는 경우, 직접 어떤 인스턴스에 어떤 프로세스를 언제 배치할지 결정해야 한다. ECS에서는 <code>Service</code>가 이러한 스케줄링을 담당하고 있는 것이다. <code>Service</code>는 인스턴스에 설치된 <code>ecs-client</code>에서 수집된 정보를 기반으로 어디에 어떤 태스크를 언제 실행할지 결정하게 된다.</p>
<p><code>Service</code>의 타입으로 두 가지 타입이 있는데, 하나는 리플리카타입, 하나는 데몬 타입이다. 데몬 타입은 컨테이너 인스턴스(위에서 설명한 것처럼, 자원 모니터링, 관리, 컨테이너 실행을 담당하는 인스턴스)에 해당하는 태스크가 하나씩만 실행된다. 이 타입은 인스턴스 관리를 위한 용도로 사용된다. 리플리카 타입을 사용하려면 태스크 개수가 지정되어 있어야 한다. <code>Service</code>는 클러스터에서 이 개수만큼만 태스크가 실행되도록 자동적으로 관리해준다. 리플리카 타입은 실제 애플리케이션용으로 주로 사용된다. 리플리카 타입인 경우, 다수의 컨테이너 인스턴스가 올라갈 때 우리는 언제 어디에서 태스크가 실행될지를 알 수는 없다. Fargate 에서는 앞서 언급한 데몬 타입의 컨테이너 인스턴스가 필요하지 않다. 따라서 Fargate 설정을 선택하면 자동적으로 리플리카만 선택할 수 있다.</p>
<hr>
<p>이제 직접 Fargate를 구성해보자. 먼저 이 글은 주관적인 경험을 작성 하고 있고, 데모를 위한 앱을 준비하지 않았다. 또한 디테일한 앱의 모습이나, 환경 변수 등도 따로 보여주지 않는다. 이미 돌아가는 앱을 Fargate에 올리는 것에만 집중한 글이다.</p>
<p>우선 현재 개발 중인 프로젝트는 다음과 같이 생긴 흔한 Node 프로젝트이다.</p>
<p><img src="/images/2020-02-22-fargate-demo/01.png"></p>
<p><code>.env</code>는 프로젝트의 환경 변수들을 모아둔 곳이고, <code>Dockerfiles</code>는 배포, 개발 환경 별 도커파일을 담아두는 곳이다.<br>현재는 개발 환경만 <code>dev.Dockerfile</code>과 <code>docker-compose.yml</code>로 도커라이징 되어 있다. 배포를 어떤 걸로 해두지 하고 있었는데, 이제 데모도 만들 겸 Fargate로 처음부터 올려보도록 하겠다.</p>
<h2 id="앱-도커라이징"><a href="#앱-도커라이징" class="headerlink" title="앱 도커라이징"></a>앱 도커라이징</h2><p>사실 도커를 사용하게 되면서 고민은 환경 변수, SecretKey 등을 어떻게 전달할 것이냐를 자주 고민했고 케이스도 많이 찾아봤다. 몇 가지 방법 중에서 자주 본 방법은</p>
<ol>
<li>.env 파일을 S3에 저장하고 환경에 맞게 <code>Dockerfile</code>에 다운로드 하고 <code>export</code>가 돌게 해라.</li>
<li>AWS Systems Manager를 사용해라 (Fargate, ECS에서 해당 서비스에서 환경 변수를 불러올 수 있다.)</li>
</ol>
<p>이 정도가 가장 기억이 난다. 위 두 가지 방법 중에 두 번째 방법을 트라이 해보고 싶은 생각은 들었지만 이번 프로젝트에서는 <code>.env</code>를 이미지 안에 붙여 넣고 <code>dotenv</code>를 사용해서 넣어줄 생각이다. 협업 하는 분들이 <code>.env</code>를 올바른 경로에 가지고 있어야 한다는 불완전성이 있지만, 개발 인원도 작고 프로젝트도 작으니 Fargate 데모에 집중하기 위해서 간단하게 시도해봤다. 우선 <code>prod.Dockerfile</code>을 만들자.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="string">node:12.15</span></span><br><span class="line"></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">/usr/src/app</span></span><br><span class="line"></span><br><span class="line"><span class="string">ENV</span> <span class="string">TZ</span> <span class="string">Asia/Seoul</span></span><br><span class="line"></span><br><span class="line"><span class="string">COPY</span> <span class="string">package.json</span> <span class="string">./</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">yarn.lock</span> <span class="string">./</span></span><br><span class="line"><span class="string">COPY</span> <span class="string">.env/prod.env</span> <span class="string">./.env</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">yarn</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="string">COPY</span> <span class="string">dist</span> <span class="string">./dist</span></span><br><span class="line"></span><br><span class="line"><span class="string">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="string">CMD</span> [<span class="string">&#x27;yarn&#x27;</span>, <span class="string">&#x27;start:docker&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>도커 이미지를 빌드 할 때 이미지를 가볍게 만들고 싶어서 정말 필요한 것만 넣었다. 컨텍스트도 줄이기 위해서 <code>.dockerignore</code>를 만들어서 복사 제외 대상을 모두 뺐다. 정상적으로 원하는 결과를 얻기 위해서는 도커 이미지를 빌드할 때 애플리케이션이 먼저 빌드 되어야 한다. 이 정도로 간단하게만 작성한 다음 AWS의 도커 이미지 레지스트리인 ECR을 사용해서 빌드한 이미지를 올려보자. 이 이미지는 이후 Fargate에서 돌아갈 컨테이너가 될 것이다.</p>
<h2 id="ECR-Elastic-Container-Registery-을-이용해-도커-이미지-버전-관리하기"><a href="#ECR-Elastic-Container-Registery-을-이용해-도커-이미지-버전-관리하기" class="headerlink" title="ECR(Elastic Container Registery)을 이용해 도커 이미지 버전 관리하기"></a>ECR(Elastic Container Registery)을 이용해 도커 이미지 버전 관리하기</h2><p>AWS ECR은 프라이빗 도커 레지스트리 서비스이다. 프라이빗 레지스트리를 관리하기 위해서 AWS의 서비스를 사용하려고 한다. 아래 명령어와는 조금 다르지만, AWS에서도 Push 명령어를 확인할 수 있다.</p>
<h3 id="저장소-만들고-도커-로그인"><a href="#저장소-만들고-도커-로그인" class="headerlink" title="저장소 만들고 도커 로그인"></a>저장소 만들고 도커 로그인</h3><p>일단 기본적으로 아래 명령어들은 <code>aws cli</code>가 설치되어 있어야 한다. 하지만 설치 과정을 설명하지는 않겠다. (얼마 전 v2가 정식 릴리즈 된 것으로 알고 있는데, 이건 v1을 기준으로 작성 했다.)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ECR 저장소 만들기</span></span><br><span class="line">aws ecr create-repository --repository-name [네임스페이스]/[레포지토리이름]</span><br><span class="line"><span class="comment"># 이름 앞에 demo는 namespace 역할을 하고 뒷 부분이 저장소 이름이 된다.</span></span><br><span class="line"><span class="comment"># ...결과가 나옴</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ECR 저장소에 로그인 하기, 파이프라인 뒤에 zsh는 각자 환경의 쉘을 사용하자</span></span><br><span class="line">aws ecr get-login --no-include-email | zsh</span><br><span class="line"><span class="comment"># 12시간동안 특정 레지스터에 유효한 토큰을 받는다. 그리고 docker login 명령어에 사용하면 도커를 업로드할 준비가 된 것. 토큰이 만료될 때까지 도커 이미지를 푸시하고 풀 할 수 있음</span></span><br><span class="line"><span class="comment"># ... 결과가 나옴</span></span><br></pre></td></tr></table></figure>

<p>이미지를 도커 파일 위치에 맞춰주고 컨텍스트는 현재 폴더로 지정한다. Dockerfile 내부에 <code>package.json</code>, <code>yarn.lock</code>, <code>.env</code> 폴더가 있는 곳을 컨텍스트로 둔 것을 가정하고 작성했기 때문에 컨텍스트는 프로젝트의 최상위가 되어야 한다. 태그는 만들었던 ECR 레포지토리로 맞춰줬는데 푸시 하기 위한 설정인 것 같다. 아래 명령어에서 <code>xxxxxxx</code> 부분은 아이디 값 처럼 생긴 고유 숫자가 들어간다. 아래 명령어를 입력하게 되면 좀 전에 만든 ECR 레포지토리로 빌드된 이미지가 올라가게 된다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image build -tag xxxxxxx.dkr.ecr.ap-northeast-2.amazonaws.com/demo/fargate-demo:latest -f ./Dockerfiles/prod.Dockerfile . <span class="comment"># 도커 이미지의 태그를 ECR 태그로 맞춘다.</span></span><br><span class="line"></span><br><span class="line">docker image push xxxxxxx.dkr.ecr.ap-northeast-2.amazonaws.com/demo/fargate-demo:latest <span class="comment"># 도커 이미지 푸시</span></span><br></pre></td></tr></table></figure>

<p>위 명령어들은 그 전의 태그들이 <code>untagged</code> 되는 것을 고려 하지 않았다. 기존 latest 태그를 다른 태그로 변경해준 다음 푸시하는 작업을 진행하는 것이 좋을 것 같다.</p>
<h2 id="ECS-시작하기"><a href="#ECS-시작하기" class="headerlink" title="ECS 시작하기"></a>ECS 시작하기</h2><p>이제 ECS를 본격적으로 배포 해볼 계획인데 아래부터 나오는 이미지의 구체적인 명명과 설명 내용을 최대한 동일하게 글을 작성했지만, 조금씩 다를 수 있다. 설명은 실제 서비스를 하면서 작성한 것이고, 캡쳐는 데모를 준비하면서 뜬 거라… 그런 것이므로 헷갈려 하지 않았으면 좋겠다.</p>
<p>AWS 콘솔에서 ECS 클러스터를 생성해야 한다. 템플릿이 총 세 가지가 있다. 여기서는 Fargate를 제공하는 네트워킹 전용 템플릿을 선택한다.</p>
<p><img src="/images/2020-02-22-fargate-demo/02.png"></p>
<p>그 다음으로 클러스터를 구성할 때는 기존의 VPC를 사용할 예정이므로 VPC 생성은 해제 상태로 두고, 컨테이너 인사이트는 뭔지 궁금하니까 눌러둔다. 예시 이미지의 컨테이너 이름은 <code>demo-cluster</code>로 하기로 했다.</p>
<p><img src="/images/2020-02-22-fargate-demo/03.png"></p>
<h3 id="Task-definition-정의하기"><a href="#Task-definition-정의하기" class="headerlink" title="Task definition 정의하기"></a>Task definition 정의하기</h3><p>이제 태스크 디피니션을 만들 것인데, 태스크 디피니션은 위에서 설명한 바와 같이 하나 이상의 컨테이너 디피니션들과 컨테이너 실행 환경에 대한 정보를 담고 있는 리소스이다. 클러스터에 종속 되어 있지 않아서 정의한 다음 다른 클러스터에서도 재사용이 가능하다. 컨테이너에서 사용하는 환경변수와 컨테이너 실행 옵션을 포함하고 있다. 개념적으로는 <code>docker-compose.yml</code>과 비슷한 역할을 한다.</p>
<p>태스크 디피니션은 내부적으로 버전 관리가 이루어지는데, 처음 <code>task</code>라는 태스크 디피니션을 만들면, 실제로는 <code>task:1</code> 이런 식으로 버전이 표기 된다. 이런 버전 하나를 리비전이라고 한다. 태스크 디피니션은 0개 이상의 리비전들로 구성된다. <code>task:1</code>인 상태에서 특정 환경 변수를 수정하고 싶을 때는 리비전을 새로 만들어야 한다. 새로 만들어진 리비전은 <code>task:2</code>가 될 것이다.</p>
<p><img src="/images/2020-02-22-fargate-demo/04.png"></p>
<p>콘솔에서 태스크 디피니션 (한국어로 작업 정의라고 표현되어있다.)을 만들자.</p>
<p><img src="/images/2020-02-22-fargate-demo/05.png"></p>
<p>파게이트로 호환 방식을 설정하고 그 다음 단계에서 이름(작업 정의 이름)과 롤(작업 역할)을 지정해야 한다. 예시에서의 이름은 <code>demo-task-def</code>로 만들고 롤을 따로 지정하지 않았다. 여기서 롤은 IAM 권한을 뜻한다.</p>
<p><img src="/images/2020-02-22-fargate-demo/06.png"></p>
<p>그 다음 태스크 실행 롤(작업 실행 역할)과 태스크 사이즈(작업 크기)를 설정해 줘야 한다. 태스크 실행 롤은 태스크에서 컨테이너 이미지를 가져오고, 사용자를 대신해서 CloudWatch에 컨테이너 로그를 게시할 때 이 역할이 필요하다고 한다. (태스크 실행에 IAM을 붙여주는 것 같음) 태스크 사이즈는 세세한 부분까지는 명확하게 이해하지는 못 했는데 태스크가 실행될 때 컴퓨팅 스팩을 정의하는 것 같았다. 우선 둘 다 가장 작은 사이즈로 골랐다. 사이즈 별로 파게이트의 요금 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://aws.amazon.com/ko/fargate/pricing/">페이지</a>에서 자세한 내용을 확인할 수 있다고 한다.</p>
<p><img src="/images/2020-02-22-fargate-demo/07.png"></p>
<p>마지막으로는 컨테이너 정의를 추가 해야 한다. 컨테이너 추가 버튼을 눌러서 컨테이너를 추가해준다.<br>컨테이너 이름으로 <code>demo-app</code>, 이미지 부분에는 <code>xxxxxxx.dkr.ecr.ap-northeast-2.amazonaws.com/demo/fargate-demo</code>를 넣어준다. 아래 많은 옵션이 있긴 한데, 작업 디렉토리를 실제 <code>Dockerfile</code>에서 작성한 곳으로 설정 해주는 것 외는 모두 디폴트로 두었다. 이후 실제 도입을 준비하면서 알아보도록 하고, 우선 기본 <code>WORKINGDIR</code>을 맞춰주는 옵션과, 80 포트와 매핑해주는 것으로 마무리 한다. 이후 아래 옵션들도 디폴트 값으로 두고 작업 정의를 생성한다.</p>
<h2 id="컨테이너-외부에-공개"><a href="#컨테이너-외부에-공개" class="headerlink" title="컨테이너 외부에 공개"></a>컨테이너 외부에 공개</h2><p>Fargate의 특성상 태스크가 어떤 인스턴스에서 실행될지 알 수 없기 때문에, 외부로 노출하기 위해서는 실행된 서비스의 위치를 파악할 필요가 있다. 이런 것을 디스커버리라고 하는데, AWS에서는 이러한 기능을 LB를 사용해 해결할 수 있다. 일반적으로 로드밸런서를 만들 듯, 이름은 <code>fargate-demo-lb</code>, ALB로 구성하고, http를 열어주었다. 4번째 단계인 라우팅 구성에서 대상 그룹을 새로 만들고, 이름을 <code>fargate-demo-group</code>으로 만들었다. 하지만 ECS 서비스 생성할 때 대상 그룹을 새로 생성해서 지금 만들어지는 대상 그룹을 사용하지 않는다 (넘어가기 위해 만든 거라고 보면 된다). 5단계에서도 바로 넘어가도록 한다.</p>
<p>만들어진 LB에 가서 이전에 http를 연결해둔 대상그룹을 삭제한다. (리스너를 삭제한다.) 마찬가지로 방금 만들었던 <code>fargate-demo-group</code>을 삭제한다.</p>
<h2 id="ECS-서비스-만들기"><a href="#ECS-서비스-만들기" class="headerlink" title="ECS 서비스 만들기"></a>ECS 서비스 만들기</h2><p>이제 서비스를 만들어보자. <code>demo-cluster</code>를 누르고 들어간 곳에서 서비스 탭에서 서비스를 생성할 수 있다. 서비스는 서비스 설정, 네트워크 설정, 오토 스케일링 설정, 리뷰 총 네 단계로 구성된다.</p>
<p><img src="/images/2020-02-22-fargate-demo/08.png"></p>
<p>먼저 서비스를 구성할텐데, 시작 유형은 <code>Fargate</code>로 설정하고, 태스크 디피니션 (작업 정의)에는 아까 만들어둔 것을 올리고, 클러스터도 <code>demo-cluster</code>로 설정한다. 플랫폼 버전은 시작 유형을 <code>Fargate</code>로 설정해야 나오는데, LATEST를 그대로 사용한다 (아마 Fargate의 버전을 말하는 게 아닐까 싶다). 작업 개수는 2개로 설정한다. 작업 개수는 태스크가 최대 몇 개나 동작할 것인가를 정하는 것이다.</p>
<p>최소 정상 상태 백분율은 (정상 상태인 태스크의 비율이 최소 얼마여야 하는가) 50으로 두고 최대 백분율을 (태스크는 최대 몇 퍼센트까지 뜰 수 있게 할 것인지) 200으로 둔다. 위에 작업 개수를 2개로 했으니 방금 설정에 따르면 Fargate에서 관리하는 태스크는 최소 1개, 최대 4개까지 뜨는 것이다.</p>
<p><img src="/images/2020-02-22-fargate-demo/09.png"></p>
<hr>
<p>그 다음으로 네트워크를 설정해줘야 한다. 이 글에서는 외부 접근이 제한된 RDS와 연결을 해야 하는 상황을 작성했다. 단지 Fargate 배포 데모 정도 구경하는 과정은 여기까지만 읽고, 네트워크 설정을 기본 디폴트로 한 다음, 자동 할당 퍼블릭 IP를 열어두는 정도로 마무리 하면 배포가 완료될 것이다.</p>
<p>프라이빗한 RDS와 연결해주려면 같은 VPC를 선택 해야 한다. 그러고나서 서브넷을 퍼블릭으로(인터넷 게이트웨이가 붙은 라우터 테이블과 연결된 서브넷) 해줬다. (설명에 프라이빗만 가능하다고 되어 있는데, 이유를 잘 모르겠다. 읽어보지 않고 했는데 잘 됐다.) 그 다음 보안 그룹을 RDS에서 접근을 허용하는 보안 그룹을 포함하고 있어야 한다. 또한 HTTP 통신만 할 예정이므로, HTTP 역시 포함 되어 있어야 한다. (HTTPS는 LB에 붙일 생각이다. HTTPS 포트로 LB에 요청이 들어오더라도, LB는 요청을 컨테이너의 80번 포트로 전달해준다.)</p>
<p>마지막으로(서비스 검색은 체크 해제한다) LB를 붙여주면 되는데, 전에 만들었던 로드밸런서를 붙이고 80번 포트를 리슨하는 것으로 해준다.</p>
<p>그 다음 단계인 오토스케일링 단계 역시 이번 데모에서 사용하지 않으므로 건너 뛰자.</p>
<p><img src="/images/2020-02-22-fargate-demo/10.png"></p>
<p>배포가 잘 이루어 지는 것을 확인했고, LB의 DNS 주소로 접근 할 수 있게 된다.</p>
<h2 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h2><p>아쉽게도 이번 데모는 성공한 여러 버전들이 프라이빗인 관계로 레포를 준비할 수 없었다. (삽질한 것들은 그냥 지웠다.) 아마 다음 오토스케일링을 볼 때에도, 프라이빗일 것 같다. 설명서를 이번에는 뒤늦게 자주 보게 되었는데, 좀 더 천천히 살펴볼 필요가 있을 것 같다. (ECS 설명서는 목차가 나름 깔끔하고 내용도 잘 읽힌다. 아래 레퍼런스 링크에서 한 번쯤은 읽어봐도 좋을 것 같다.)</p>
<p>ECS Fargate의 가격적인 측면을 사실 간과할 수 없다고들 하는데, 경험하지 못해서 그런지, 설명만 봐서는 그렇게 무자비한 가격은 아니라고 생각한다. Lambda와 비교하자면 더 비쌀 것 같긴 한데, (작은 서비스일수록, 프리티어가 해결해주는 범위 내면 싸다고 볼 수 있다.) 일반적으로 만들어지는 모놀리식한 방식의 앱을 배포할 수 있는 좋은 방법이 될 것 같다. 사실 도커라이징을 한 다음, EC2에 배포하기에 뭔가 아쉬운 점이 있어서 지금까지 그렇게 해본 적은 없는데, 항상 바라던 서비스가 아닌가 싶은 느낌이 든다 (쿠버네티스는 사용한 적 없어서 비교할 수 없다.).</p>
<p>다만 다시 한 번 확인해야 하는 점은 오토 스케일링인데, 서버리스라는 이름과 맞지 않게 오토 스케일링을 적용한다? 라는 말이 있어서 갸웃 했다. 맥시멈, 미니멈만 정해주면 알아서 오토 스케일링이 적용 되는 게 아닌가? 싶었다. 고민 해보면 기본적으로 원래 ECS가 EC2컨테이너를 사용한 도커 서비스라는 점 때문에(결국에 EC2를 어떻게 돌릴 것인가에 대한 설정이 필요한 건지?.. 내공이 부족하여 디테일 함 없이 둥실둥실 떠다니는 정도의 생각밖에 못 한다.) 람다와 같은 완전 서버리스같은 느낌이 덜 나는 것이 아닌가 싶다. ECS Fargate의 오토스케일링에 대해서 다음 번에는 공부해보고 도입해봐야겠다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.44bits.io/ko/post/container-orchestration-101-with-docker-and-aws-elastic-container-service#%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0cluster%EC%99%80-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4cluster-instance">https://www.44bits.io/ko/post/container-orchestration-101-with-docker-and-aws-elastic-container-service#%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0cluster%EC%99%80-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4cluster-instance</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.44bits.io/ko/post/getting-started-with-ecs-fargate#ecselastic-container-service-%EA%B8%B0%EC%B4%88">https://www.44bits.io/ko/post/getting-started-with-ecs-fargate#ecselastic-container-service-%EA%B8%B0%EC%B4%88</a></li>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://docs.aws.amazon.com/ko_kr/AmazonECS/latest/developerguide/clusters.html">https://docs.aws.amazon.com/ko_kr/AmazonECS/latest/developerguide/clusters.html</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>컨테이너 서버리스 Fargate 배포하기</p><p><a href="https://changhoi.kim/posts/docker/fargate-demo/">https://changhoi.kim/posts/docker/fargate-demo/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>changhoi</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-02-22</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2020-02-22</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/docker/">docker</a><a class="link-muted mr-2" rel="tag" href="/tags/serverless/">serverless</a><a class="link-muted mr-2" rel="tag" href="/tags/aws/">aws</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><div class="card"><div class="card-content"><h3 class="title is-5">관련 글</h3><article class="media"><figure class="media-left"><a class="image" href="/posts/database/dynamodb-internals-2/"><img src="/images/2022-04-16-dynamodb-internals-1/thumbnail.png" alt="DynamoDB Internals (2) - DynamoDB"></a></figure><div class="media-content"><p class="date"><time datetime="2022-04-18T15:00:00.000Z">2022-04-19</time></p><p class="title"><a href="/posts/database/dynamodb-internals-2/">DynamoDB Internals (2) - DynamoDB</a></p><p class="categories"><a href="/categories/database/">database</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/database/dynamodb-single-table-design/"><img src="/images/2022-04-16-dynamodb-internals-1/thumbnail.png" alt="DynamoDB 설계 방법: Single Table Design"></a></figure><div class="media-content"><p class="date"><time datetime="2020-10-23T15:00:00.000Z">2020-10-24</time></p><p class="title"><a href="/posts/database/dynamodb-single-table-design/">DynamoDB 설계 방법: Single Table Design</a></p><p class="categories"><a href="/categories/database/">database</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/backend/serverside-typescript-setting-03/"><img src="https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2018/08/typescriptfeature.png" alt="Monolithic 서버사이드 타입스크립트 세팅 03"></a></figure><div class="media-content"><p class="date"><time datetime="2020-03-12T15:00:00.000Z">2020-03-13</time></p><p class="title"><a href="/posts/backend/serverside-typescript-setting-03/">Monolithic 서버사이드 타입스크립트 세팅 03</a></p><p class="categories"><a href="/categories/backend/">backend</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/serverless/serverless-deployment-best-practices/"><img src="https://s3-us-west-2.amazonaws.com/assets.blog.serverless.com/2019-10-deployment-best-practices/safeguard-hero.png" alt="서버리스 배포 베스트 프랙티스(번역)"></a></figure><div class="media-content"><p class="date"><time datetime="2020-03-08T15:00:00.000Z">2020-03-09</time></p><p class="title"><a href="/posts/serverless/serverless-deployment-best-practices/">서버리스 배포 베스트 프랙티스(번역)</a></p><p class="categories"><a href="/categories/serverless/">serverless</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/serverless/serverless-vpc-deploy-demo/"><img src="/images/2020-03-05-serverless-vpc-deploy-demo/thumbnail.png" alt="Serverless + S3 + DyanamoDB VPC에 배포하고 외부와 연결하기"></a></figure><div class="media-content"><p class="date"><time datetime="2020-03-04T15:00:00.000Z">2020-03-05</time></p><p class="title"><a href="/posts/serverless/serverless-vpc-deploy-demo/">Serverless + S3 + DyanamoDB VPC에 배포하고 외부와 연결하기</a></p><p class="categories"><a href="/categories/serverless/">serverless</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/docker/Use-multiple-Dockerfiles-for-complex-application-configuration/"><img src="https://cdn.ttgtmedia.com/visuals/searchCloudComputing/infrastructure/cloudcomputing_article_011.jpg" alt="복잡한 애플리케이션 설정을 위한 복수의 도커 파일 사용하기(번역)"></a></figure><div class="media-content"><p class="date"><time datetime="2020-03-01T15:00:00.000Z">2020-03-02</time></p><p class="title"><a href="/posts/docker/Use-multiple-Dockerfiles-for-complex-application-configuration/">복잡한 애플리케이션 설정을 위한 복수의 도커 파일 사용하기(번역)</a></p><p class="categories"><a href="/categories/docker/">docker</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/serverless/serverless-cronjob-crawler-demo/"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAolBMVEUAAAD+V1H/WVP/WlRoJiSmPzwGAADRVVL3X1lmLizcU1D/WFCaPjsAAQDPTUsAAAPCS0f/Xlf/XFo/Hx5hLCtpLC1UKSf/W1LVUEz/VlbPTkd0MTDGS0a9S0h7NS8jCwqONzXsXFUnFBJSIyGjQj6YPzxJHhs2GRg/GxqGODdeJSQeCwrsWVanREBBFhVJIBzcXVW9SkUXCwt9OTi4VVWpSkrtSDTvAAADZ0lEQVR4nO3bW1vaMBzH8TSdnGKNrTJlypSJYzo8b+//rS14ASQUmpaLJuz7uVL857G/J+kpIUIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0cdavcm7VZ6bFsLKNKfnaUqAN03S3UXoq9Fq9Ft0LKSsapabisrVIjuNkN5UOTb+ty82HFY1MxehbS4E2HMuKY+05Da6KynhJIpU6aSVOiaqE8tppMPYIaDo5noTpd6dB79AS5jd2fT89tITWgZpLzlvVeRtbQnlrVWsx8QkYUUKV/7DuhuIur75TxJNQmT8NRKY7y+JMTL0GaSwJzV1tdO+UT5LDOg9V8dOufs69unDRNIqEqZw41ffS44ntM6AMJ+Guw1RPTvVASc8rTRLOc2m+9QWhSIs7u3iWmw995EUeTB/++rLD0Cme7Sp23JX+OwAAgIhkwn5xDlBWXRK/0DuhfaEMg/7RFufWIWZiuq1wi4fWIjmOU1mqeLTrbvKkvLCUkhfBvB9um8WYCL3qQ/PTrddc9+odP/x5mrHorFVpcVInYAwJ0759pfjtPckWS8JeZz2hFle1BmnwCc1Hp9bVviOu/SYRY0loBumVU+a1ahhNQqk2lraHqd96RSQJ1WLVMLMe2ryWtuNJmKTprVM1r3cahp5QjvKZXfSYey5XRJJQJQOn6Eke1nkolbtqOK/ZhWElLDm8/NmueSl8vgZluQhnde2+t6F4ra6p1m0lTpnOJut5JsvE4pOyut1aS+RldTPMms0qhT0FojdnIGrPSGShzGEAAIAy2rpV7/FoEs4tX6+zI2XmV91IW2G8rB1dpvfpiFBiPgxs1vyFFmeDpsZtJXI57/ju/IXnt55dUslw9j1ZEeTUuUS8NgoY1iyGlTB/sSdKZz6bnKJKOLf+pmuuGkaQUC4uD6tRqsVls4BhJlzsrkit/aKZuClqTrGFnXC0uSDz0exKGmjCRS++mYG5PkhPGwYMNWGSO6uG7zVXDQNPaM643rt9r6i5tB16wsTZa2ieScdNT8MwE0prQ+xnV84Tv31ckSRM1PqG2MWL02Mq1SElVIn7rHzUeJAGlfCju/ThvNL96e7jb0uB/O29dhTKG/CSs5aSZXtF1AHN0yw5S04BHiEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPg//AO9zTv9FO6XegAAAABJRU5ErkJggg==" alt="서버리스로 CronJob 만들기 (코로나 크롤러)"></a></figure><div class="media-content"><p class="date"><time datetime="2020-02-29T15:00:00.000Z">2020-03-01</time></p><p class="title"><a href="/posts/serverless/serverless-cronjob-crawler-demo/">서버리스로 CronJob 만들기 (코로나 크롤러)</a></p><p class="categories"><a href="/categories/serverless/">serverless</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/serverless/serverless-architecture-pattern/"><img src="https://miro.medium.com/max/730/1*Fjsk_yELuDAavR8sXOW6Sg.png" alt="서버리스 아키텍처 패턴"></a></figure><div class="media-content"><p class="date"><time datetime="2019-12-08T15:00:00.000Z">2019-12-09</time></p><p class="title"><a href="/posts/serverless/serverless-architecture-pattern/">서버리스 아키텍처 패턴</a></p><p class="categories"><a href="/categories/serverless/">serverless</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/serverless/serverless-framework-quicklearn-(1)/"><img src="https://files.readme.io/ffb4c59-Serverless.png" alt="Serverless 프레임워크 빠르게 배우기 (1)"></a></figure><div class="media-content"><p class="date"><time datetime="2019-11-23T15:00:00.000Z">2019-11-24</time></p><p class="title"><a href="/posts/serverless/serverless-framework-quicklearn-(1)/">Serverless 프레임워크 빠르게 배우기 (1)</a></p><p class="categories"><a href="/categories/serverless/">serverless</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/linux/add-user-to-docker-group/"><img src="/images/2019-11-10-detail-of-ls/01.png" alt="리눅스에서 Docker 명령어 sudo 없이 사용하기"></a></figure><div class="media-content"><p class="date"><time datetime="2019-11-09T15:00:00.000Z">2019-11-10</time></p><p class="title"><a href="/posts/linux/add-user-to-docker-group/">리눅스에서 Docker 명령어 sudo 없이 사용하기</a></p><p class="categories"><a href="/categories/linux/">linux</a></p></div></article></div></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/serverless/serverless-cronjob-crawler-demo/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">서버리스로 CronJob 만들기 (코로나 크롤러)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/etc/react-redux-hooks/"><span class="level-item">React환경에서 Hooks로 Redux 사용 하기</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">댓글</h3><div class="fb-comments" data-width="100%" data-href="https://changhoi.kim/posts/docker/fargate-demo/" data-num-posts="5"></div><script>(function(d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return;
            js = d.createElement(s); js.id = id;
            js.src = "//connect.facebook.net/ko/sdk.js#xfbml=1&version=v12.0";
            fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars2.githubusercontent.com/u/34329147?s=400&amp;u=9d1b1dc88bc8ee5965f35b0160780264c3619eb6&amp;v=4" alt="Changhoi Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Changhoi Kim</p><p class="is-size-6 is-block">Co-Founder of Bayesians</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul, Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives/"><p class="title">75</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories/"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags/"><p class="title">47</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.linkedin.com/in/changhoi/" target="_blank" rel="external nofollow noopener noreferrer">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="LinkedIn" href="https://www.linkedin.com/in/changhoi/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/changhoi"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Email" href="mailto:changhoi0522@gmail.com"><i class="fas fa-envelope-square"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="English" href="https://jayce.kim"><i class="fas fa-language"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/backend/"><span class="level-start"><span class="level-item">backend</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/books/"><span class="level-start"><span class="level-item">books</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/database/"><span class="level-start"><span class="level-item">database</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/essay/"><span class="level-start"><span class="level-item">essay</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/etc/"><span class="level-start"><span class="level-item">etc</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/logs/"><span class="level-start"><span class="level-item">logs</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/os/"><span class="level-start"><span class="level-item">os</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/rust/"><span class="level-start"><span class="level-item">rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/serverless/"><span class="level-start"><span class="level-item">serverless</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">카탈로그</h3><ul class="menu-list"><li><a class="level is-mobile" href="#클러스터와-컨테이너-인스턴스"><span class="level-left"><span class="level-item">1</span><span class="level-item">클러스터와 컨테이너 인스턴스</span></span></a></li><li><a class="level is-mobile" href="#Task-Task-definition"><span class="level-left"><span class="level-item">2</span><span class="level-item">Task &amp; Task definition</span></span></a></li><li><a class="level is-mobile" href="#Service"><span class="level-left"><span class="level-item">3</span><span class="level-item">Service</span></span></a></li><li><a class="level is-mobile" href="#앱-도커라이징"><span class="level-left"><span class="level-item">4</span><span class="level-item">앱 도커라이징</span></span></a></li><li><a class="level is-mobile" href="#ECR-Elastic-Container-Registery-을-이용해-도커-이미지-버전-관리하기"><span class="level-left"><span class="level-item">5</span><span class="level-item">ECR(Elastic Container Registery)을 이용해 도커 이미지 버전 관리하기</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#저장소-만들고-도커-로그인"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">저장소 만들고 도커 로그인</span></span></a></li></ul></li><li><a class="level is-mobile" href="#ECS-시작하기"><span class="level-left"><span class="level-item">6</span><span class="level-item">ECS 시작하기</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Task-definition-정의하기"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">Task definition 정의하기</span></span></a></li></ul></li><li><a class="level is-mobile" href="#컨테이너-외부에-공개"><span class="level-left"><span class="level-item">7</span><span class="level-item">컨테이너 외부에 공개</span></span></a></li><li><a class="level is-mobile" href="#ECS-서비스-만들기"><span class="level-left"><span class="level-item">8</span><span class="level-item">ECS 서비스 만들기</span></span></a></li><li><a class="level is-mobile" href="#후기"><span class="level-left"><span class="level-item">9</span><span class="level-item">후기</span></span></a></li><li><a class="level is-mobile" href="#Reference"><span class="level-left"><span class="level-item">10</span><span class="level-item">Reference</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.jpg" alt="Changhoi Kim" height="28"></a><p class="is-size-7"><span>&copy; 2026 changhoi</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="external nofollow noopener noreferrer" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>