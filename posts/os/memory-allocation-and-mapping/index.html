<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>메모리 할당과 매핑 - Changhoi Kim</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="white"><meta name="application-name" content="Changhoi Kim"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="msapplication-TileColor" content="white"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Changhoi Kim"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="우리는 코드를 짤 때, 실제 메모리 위치를 알고 코드를 쓰지 않는다. count :&amp;#x3D; 10 이라는 코드를 쓰면, count라는 변수가 메모리 어디에 위치하는지를 알고 짜는 것은 아니다. 프로그램을 동작시키려면 메모리에 올려야 하는데, 이 과정에서 발생하는 우리가 짠 코드가 실제 메모리에는 어떻게 올라가고, 어떻게 주소를 찾아가는지에 대한 이야기이다."><meta property="og:type" content="blog"><meta property="og:title" content="메모리 할당과 매핑"><meta property="og:url" content="https://changhoi.kim/posts/os/memory-allocation-and-mapping/"><meta property="og:site_name" content="Changhoi Kim"><meta property="og:description" content="우리는 코드를 짤 때, 실제 메모리 위치를 알고 코드를 쓰지 않는다. count :&amp;#x3D; 10 이라는 코드를 쓰면, count라는 변수가 메모리 어디에 위치하는지를 알고 짜는 것은 아니다. 프로그램을 동작시키려면 메모리에 올려야 하는데, 이 과정에서 발생하는 우리가 짠 코드가 실제 메모리에는 어떻게 올라가고, 어떻게 주소를 찾아가는지에 대한 이야기이다."><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://changhoi.kim/images/2021-09-09-memory-allocation-and-mapping/00.png"><meta property="article:published_time" content="2021-09-08T15:00:00.000Z"><meta property="article:modified_time" content="2021-09-08T15:00:00.000Z"><meta property="article:author" content="changhoi"><meta property="article:tag" content="cs"><meta property="article:tag" content="memory"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://changhoi.kim/images/2021-09-09-memory-allocation-and-mapping/00.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://changhoi.kim/posts/os/memory-allocation-and-mapping/"},"headline":"메모리 할당과 매핑","image":["https://changhoi.kim/images/2021-09-09-memory-allocation-and-mapping/00.png"],"datePublished":"2021-09-08T15:00:00.000Z","dateModified":"2021-09-08T15:00:00.000Z","author":{"@type":"Person","name":"changhoi"},"publisher":{"@type":"Organization","name":"Changhoi Kim","logo":{"@type":"ImageObject","url":"https://changhoi.kim/img/logo.jpg"}},"description":"우리는 코드를 짤 때, 실제 메모리 위치를 알고 코드를 쓰지 않는다. count :&#x3D; 10 이라는 코드를 쓰면, count라는 변수가 메모리 어디에 위치하는지를 알고 짜는 것은 아니다. 프로그램을 동작시키려면 메모리에 올려야 하는데, 이 과정에서 발생하는 우리가 짠 코드가 실제 메모리에는 어떻게 올라가고, 어떻게 주소를 찾아가는지에 대한 이야기이다."}</script><link rel="canonical" href="https://changhoi.kim/posts/os/memory-allocation-and-mapping/"><link rel="alternate" href="/rss2.xml" title="Changhoi Kim" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-QBSLW6WTZW" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-QBSLW6WTZW');</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.jpg" alt="Changhoi Kim" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/images/2021-09-09-memory-allocation-and-mapping/00.png" alt="메모리 할당과 매핑"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-09-08T15:00:00.000Z" title="9/9/2021, 12:00:00 AM">2021-09-09</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2021-09-08T15:00:00.000Z" title="9/9/2021, 12:00:00 AM">2021-09-09</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/os/">os</a></span><span class="level-item">32분안에 읽기 (약 4828 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile">메모리 할당과 매핑</h1><div class="content"><p>우리는 코드를 짤 때, 실제 메모리 위치를 알고 코드를 쓰지 않는다. <code>count := 10</code> 이라는 코드를 쓰면, <code>count</code>라는 변수가 메모리 어디에 위치하는지를 알고 짜는 것은 아니다. 프로그램을 동작시키려면 메모리에 올려야 하는데, 이 과정에서 발생하는 우리가 짠 코드가 실제 메모리에는 어떻게 올라가고, 어떻게 주소를 찾아가는지에 대한 이야기이다.</p>
<span id="more"></span>

<h1 id="Continuous-Memory-Allocation"><a href="#Continuous-Memory-Allocation" class="headerlink" title="Continuous Memory Allocation"></a>Continuous Memory Allocation</h1><p>연속 메모리 할당 방식은 초기 버전의 메모리 할당 방식에 해당한다. 가장 쉬운 방법으로는 고정된 크기로 메모리를 나눠 프로세스에게 할당해주는 방식이 있고, 효율적인 메모리 분배를 위해 파티션을 프로세스 크기에 따라 나누는 방법이 있다.</p>
<h2 id="Fixed-Partition-FPM-고정-분할"><a href="#Fixed-Partition-FPM-고정-분할" class="headerlink" title="Fixed Partition (FPM, 고정 분할)"></a>Fixed Partition (FPM, 고정 분할)</h2><p>이름대로, 고정된 크기로 메모리를 나누는 방식이다. 각 분할마다 한 프로세스를 가지게 되며, 이때 분할의 개수를 <strong>다중 프로그래밍 정도</strong>(Multiprogarmming Degree)라고 한다. 한 분할이 비게 되면 프로세스가 입력 큐(<code>input queue</code>)에서 선택되어 빈 분할로 들어오게 된다. 이 방식은 내부 단편화와 외부 단편화 모두 발생할 수 있다.</p>
<h2 id="Variable-Partition-VPM-가변-분할"><a href="#Variable-Partition-VPM-가변-분할" class="headerlink" title="Variable Partition (VPM, 가변 분할)"></a>Variable Partition (VPM, 가변 분할)</h2><p>가변 분할 방식에서는 어떤 부분이 사용되었는지를 파악하는 테이블을 사용해야 한다. 초기에는 하나의 큰 사용 가능한 블록, <strong>hole</strong>이 있는 상태라고 한다. 프로세스가 <code>input queue</code>에 들어오면 프로세스가 사용할 메모리를 확인하고, 남은 공간이 있다면 필요한 메모리만큼 할당해준다. 이 방식에서는 내부 단편화가 발생할 수 없지만, 여러 프로세스에 메모리를 할당하고 빼주는 과정을 거치다 보면 외부 단편화 문제는 발생할 수 있다. 예를 들어, 다음 시나리오를 생각해보자.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">매모리 공간 55MB</span><br><span class="line"></span><br><span class="line">1. P1 적재 -&gt; 20MB</span><br><span class="line">2. P2 적재 -&gt; 10MB</span><br><span class="line">3. P3 적재 -&gt; 10MB</span><br><span class="line">3. P4 적재 -&gt; 10MB</span><br><span class="line">4. P1, P3, P4 종료</span><br><span class="line">5. P5 적재 -&gt; 30MB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>위 시나리오에서 초기 상태, 메모리 사용 상태를 파악하는 <strong>파티션 테이블</strong>은 다음과 같다.  </p>
<img src="/images/2021-09-09-memory-allocation-and-mapping/01.png?style=centerme" width="500" height="200">

  
  

<p><code>P4</code>까지 적재된 후의 상태는 다음과 같다.  </p>
<img src="/images/2021-09-09-memory-allocation-and-mapping/02.png?style=centerme" width="500" height="200">
  
  

<p>이제 <code>P1</code>, <code>P3</code>, <code>P4</code>가 종료 되고 나면 Partition 1, 3, 4는 빈 공간이 되고, 3, 4번 파티션이 합쳐진다.  </p>
<blockquote>
<p>이렇게 빈 영역을 하나의 파티션으로 합치는 것을 <code>Coalescing holes</code>(공간 통합)라고 한다.</p>
</blockquote>
<img src="/images/2021-09-09-memory-allocation-and-mapping/03.png?style=centerme" width="500" height="200">


<p>현재 남은 공간은 총 45MB이지만, 이는 연속되지 않았기 때문에 <code>P5</code>를 적재할 수 없는 상태이다. 즉, 외부 단편화가 발생하는 상황인 것이다.</p>
<hr>
<h2 id="메모리-배치-전략"><a href="#메모리-배치-전략" class="headerlink" title="메모리 배치 전략"></a>메모리 배치 전략</h2><p>위와 같은 예시 상태에서, <code>P5</code>가 10MB라고 가정해보자. 현재 남은 파티션은 1, 3이고 두 파티션 모두 적재할 수 있는 크기이다. 그렇다면 어디에 배치할 수 있을까? 이것을 결정하는 문제의 해결책은 대표적으로 <strong>최초 적합</strong>(<strong>First-fit</strong>), <strong>최적 적합</strong>(<strong>Best-fit</strong>), <strong>최악 적합</strong>(<strong>Worst-fit</strong>)이 있다.</p>
<h3 id="최초-적합-First-fit"><a href="#최초-적합-First-fit" class="headerlink" title="최초 적합 (First-fit)"></a>최초 적합 (First-fit)</h3><p>메모리 가용 파티션 중 첫 번째로 사용 가능한 공간을 할당해준다. 검색 시작은 집합의 시작에서부터 하거나, 지난 번에 검색이 끝났던 위치부터 시작할 수 있다.</p>
<blockquote>
<p>지난 번에 검색이 끝났던 위치부터 시작하는 경우를 <strong>Next-fit</strong>으로 구분하기도 한다. 이 방식을 사용하면 메모리가 한 쪽만 지나치게 사용되는 문제를 해결할 수 있다.</p>
</blockquote>
<h3 id="최적-적합-Best-fit"><a href="#최적-적합-Best-fit" class="headerlink" title="최적 적합 (Best-fit)"></a>최적 적합 (Best-fit)</h3><p>사용 가능한 공간들 중에서 가장 작은 것을 선택한다. 리스트가 크기 순서로 되어있지는 않으므로 모든 리스트를 탐색해야 하는 오버해드가 존재한다. 이 방식은 아주 작은 파티션을 만들어낸다.</p>
<h3 id="최악-적합-Worst-fit"><a href="#최악-적합-Worst-fit" class="headerlink" title="최악 적합 (Worst-fit)"></a>최악 적합 (Worst-fit)</h3><p>가장 큰 가용 공간을 선택한다. 마찬가지로 리스트가 크기 순서로 정렬되어있지 않다면 모두 탐색해야 한다. 이 방식은 남게 되는 공간이 비교적 클 확률이 높다.</p>
<blockquote>
<p>이 세 가지 방식 중 어떤 것이 더 낫다는 이론적으로 확정할 수는 없지만 모의 실험을 해봤을 때, 시간과 메모리 이용 효율 측면에서 최악 적합이 가장 안 좋았고, 최초 적합과 최적 적합이 공간 효율성은 비슷했지만 속도 면에서 최초 적합이 더 빠르게 나타났다고 한다.</p>
</blockquote>
<hr>
<h1 id="Non-Continuous-Memory-Allocation"><a href="#Non-Continuous-Memory-Allocation" class="headerlink" title="Non-Continuous Memory Allocation"></a>Non-Continuous Memory Allocation</h1><p>어떻게 하면 외부 단편화 문제를 완화할 수 있을까? 가변 분할 방식에서 외부 단편화는 프로세스가 메모리에 적재 되었다가, 빠지는 과정을 반복하면서, 불연속적인 공간이 남는 것으로 인해 발생했다. 그렇다면, 이런 불연속한 부분을 사용 중인 영역을 밀어 올려 없애는 걸 생각해볼 수 있을 것 같다. 이 방식을 <code>Storage Compaction</code>(메모리 압축)이라고 한다. 프로세스 처리에 필요한 적재 공간을 확보해야 할 때 사용할 수 있다. 예를 들어서, 위 테이블을 재배치 하면 다음과 같이 변경된다.  </p>
<p><img src="/images/2021-09-09-memory-allocation-and-mapping/04.png?style=centerme"></p>
<p>그러나 이 방식은, 프로세스를 모두 중지 해야 하고, 많은 시스템 자원을 소비하는 방식이다.<br>이 문제를 해결하는 다른 접근 방식은 한 프로세스의 논리 주소 공간을 여러 비연속적인 공간으로 나눠 필요한 크기의 공간을 사용할 수 있을때 메모리에 할당해주는 방식이다. 이를 <code>Non-Continuous Memory Allocation</code>이라고 한다. 정확하게는, 사용자 프로그램을 여러개의 블록으로 분할하고, <code>swap-device</code>에 모두 두고, 실행시 필요한 블록만 메인 메모리에 적재하는 방식이다. 이를 구현한 방식이 페이징(<code>Paging</code>)과 세그먼테이션(<code>Segmentation</code>)이다. 두 방식은 결합되어 사용될 수도 있다</p>
<h2 id="Address-Mapping"><a href="#Address-Mapping" class="headerlink" title="Address Mapping"></a>Address Mapping</h2><p>Address Mapping은, 연속 할당 방식에서는, 상대 주소를 물리 주소로 “재배치”하는 작업을 뜻했다. 불연속 메모리 할당 방식에서는 <code>Virtual Address</code> (가상 주소) 개념이 등장한다. 이는 연속 메모리 할당 방식의 “상대 주소”와 같다고 볼 수 있다. <code>Real Address</code>는 물리 주소와 같은 소리이고, 실제 메모리 주소를 뜻한다. 불연속 메모리 할당 방식의 메모리 매핑은 가상 주소를 실제 주소로 바꿔주는 과정이다.  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[User process의 Virtual Address] -&gt; (Address Mapping) -&gt;[Real Address]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>논리적, 가상적의 뉘앙스의 메모리는 프로그램이 가지고 있는 연속을 가정한 가상의 주소 형태라고 볼 수 있다. 대체적으로, <strong>시작점을 찾을 수 있는 단서</strong>와 <strong>시작점으로부터 얼마나 많이 떨어져 있는가</strong>와 같은 튜플로 구성된다. 물리적, 실제의 뉘앙스의 메모리는 메인 메모리의 위치이다.  </p>
</blockquote>
<h3 id="Block-Mapping"><a href="#Block-Mapping" class="headerlink" title="Block Mapping"></a>Block Mapping</h3><p>사용자 프로그램을 블록 단위로 분할하고 관리하는 시스템에서의 매핑 방식이다. 가상 주소를 <strong>블록 숫자</strong>와 얼마나 <strong>시작점에서 떨어져있는지</strong>에 대한 정보를 가지고 표현한다.  </p>
<p>즉, <code>V = (b, d)</code>로 표현하는데, <code>b</code>는 <code>block number</code>를 뜻하고, <code>d</code>는 <code>displacement</code>를 의미한다.  </p>
<blockquote>
<p><code>displacement</code>는 쉽게 말해 <code>offset</code>이다. <code>block number</code>로부터 블록의 실제 메모리 주소를 가지고, 해당 Instruction이 시작점으로부터 얼마나 떨어진 명령인지 알려주는 역할을 한다.  </p>
</blockquote>
<p>Address Mapping 정보는  <code>Block Map Table</code>(<code>BMT</code>)에서 관리된다. 프로세스마다 하나의 <code>BMT</code>를 커널 공간에 가지고 있다. <code>BMT</code>가 관리하는 정보는 대략 다음과 같다.  </p>
<p><img src="/images/2021-09-09-memory-allocation-and-mapping/05.png?style=centerme"></p>
<blockquote>
<p><code>residence bit</code>는 해당 블록이 메모리에 올라간 상태인지를 나타내주는 비트이다.  </p>
</blockquote>
<h2 id="V-b-d-로-표현되면-먼저-BMT에서-b에-해당하는-열을-찾는다-해당-열에서는-블록이-메모리에-적재된-상태인지-아닌지-확인-후-적재된-상태라면-Real-Address를-받아와서-d와-함께-명령어-주소를-찾는다-적재되지-않은-상태라면-해당-블록을-메모리에-올리고-BMT를-업데이트-하고-Real-Address를-받아와-명령어-주소를-계산한다-사용자-프로그램을-여러-개의-블록으로-분할하고-swap-device에-모두-두고-실행-시-필요한-블록만-메인-메모리에-적재하는-방식이다-이-방식은-구체적인-구현이라기-보단-Non-continuous-Memory-Allocation에서-주로-사용하는-메모리-매핑-방법이다-이후-구체적으로-페이징-방식이나-세그먼테이션-방식에서-어떻게-주소를-찾아주는지-나온다"><a href="#V-b-d-로-표현되면-먼저-BMT에서-b에-해당하는-열을-찾는다-해당-열에서는-블록이-메모리에-적재된-상태인지-아닌지-확인-후-적재된-상태라면-Real-Address를-받아와서-d와-함께-명령어-주소를-찾는다-적재되지-않은-상태라면-해당-블록을-메모리에-올리고-BMT를-업데이트-하고-Real-Address를-받아와-명령어-주소를-계산한다-사용자-프로그램을-여러-개의-블록으로-분할하고-swap-device에-모두-두고-실행-시-필요한-블록만-메인-메모리에-적재하는-방식이다-이-방식은-구체적인-구현이라기-보단-Non-continuous-Memory-Allocation에서-주로-사용하는-메모리-매핑-방법이다-이후-구체적으로-페이징-방식이나-세그먼테이션-방식에서-어떻게-주소를-찾아주는지-나온다" class="headerlink" title="V = (b, d)로 표현되면, 먼저 BMT에서 b에 해당하는 열을 찾는다. 해당 열에서는 블록이 메모리에 적재된 상태인지 아닌지 확인 후, 적재된 상태라면 Real Address를 받아와서 d와 함께 명령어 주소를 찾는다. 적재되지 않은 상태라면 해당 블록을 메모리에 올리고 BMT를 업데이트 하고 Real Address를 받아와 명령어 주소를 계산한다.사용자 프로그램을 여러 개의 블록으로 분할하고, swap-device에 모두 두고, 실행 시 필요한 블록만 메인 메모리에 적재하는 방식이다.&gt; 이 방식은 구체적인 구현이라기 보단, Non-continuous Memory Allocation에서 주로 사용하는 메모리 매핑 방법이다. 이후, 구체적으로 페이징 방식이나, 세그먼테이션 방식에서 어떻게 주소를 찾아주는지 나온다.
  "></a><code>V = (b, d)</code>로 표현되면, 먼저 <code>BMT</code>에서 <code>b</code>에 해당하는 열을 찾는다. 해당 열에서는 블록이 메모리에 적재된 상태인지 아닌지 확인 후, 적재된 상태라면 <code>Real Address</code>를 받아와서 <code>d</code>와 함께 명령어 주소를 찾는다. 적재되지 않은 상태라면 해당 블록을 메모리에 올리고 <code>BMT</code>를 업데이트 하고 <code>Real Address</code>를 받아와 명령어 주소를 계산한다.<br>사용자 프로그램을 여러 개의 블록으로 분할하고, <code>swap-device</code>에 모두 두고, 실행 시 필요한 블록만 메인 메모리에 적재하는 방식이다.<br><br>&gt; 이 방식은 구체적인 구현이라기 보단, <code>Non-continuous Memory Allocation</code>에서 주로 사용하는 메모리 매핑 방법이다. 이후, 구체적으로 페이징 방식이나, 세그먼테이션 방식에서 어떻게 주소를 찾아주는지 나온다.
  </h2><h2 id="Paging-System"><a href="#Paging-System" class="headerlink" title="Paging System"></a>Paging System</h2><p>프로그램을 같은 크기의 블록으로 분할하는 방식이다. 나누어진 블록을 <code>Page</code>(페이지)라고 부르고, 메모리의 분할 영역을 <code>Page Frame</code>(페이지 프레임)이라고 부른다. 페이지와 페이지 프레임은 같은 크기이다. 프로세스는 분할된 페이지로 나눠져 예비 저장 장치 또는 파일 시스템에 놓여진다. 나눠진 페이지 중 사용되는 페이지를 메모리에 올리는 방식이다.  </p>
<blockquote>
<p>교과서와 다르게, 강의에서는 예비 저장 장치, 파일 시스템은 <code>Secondary Storage</code> &#x2F; <code>Swap Device</code>로 지칭되었는데 같은 의미로 봐도 될 것 같다.  </p>
</blockquote>
<p>우선 가장 큰 특징은 논리적 분할이 아니라 크기에 따른 분할이다. 이러한 특징으로 인해, 이후 세그먼테이션에서 확인할 수 있겠지만, 페이지 공유나 보호 과정이 복잡하다. 그러나 단순한 설계 방식으로 효율적으로 관리할 수 있다. 또한 외부 단편화는 발생할 수 없지만, 내부 단편화는 발생할 수 있다.  </p>
<blockquote>
<p>OSX의 기본 페이지 사이즈는 4096Bytes인 것 같다. <code>vm_stat</code> 명령어로 터미널에서 현재 가상 메모리 상태를 확인할 수 있다. 나타내는 구체적인 정보는 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.oreilly.com/library/view/mac-os-x/0596003560/ch08s01s05.html">이 링크</a>에서 확인할 수 있다.</p>
</blockquote>
<p><img src="/images/2021-09-09-memory-allocation-and-mapping/vmstat.png?style=centerme" alt="vm_stat 명령어 결과"></p>
<h3 id="Address-Mapping-1"><a href="#Address-Mapping-1" class="headerlink" title="Address Mapping"></a>Address Mapping</h3><p>위의 블록 매핑 방식과 유사하다. 블록이라는 이름 대신 페이지를 사용하는 것이라고 볼 수 있다. 가상 주소를 다음과 같이 표현할 수 있다.   </p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V = (p, d)</span><br><span class="line">p: page number</span><br><span class="line">d: displacement</span><br></pre></td></tr></table></figure>
<p>위 정보와 함께, 물리 주소를 찾기 위해 페이지 <code>PMT</code>(<code>Page Map Table</code>)를 사용한다. 페이지 테이블은 대략 다음과 같이 생겼다.  </p>
<p><img src="/images/2021-09-09-memory-allocation-and-mapping/06.png?style=centerme"></p>
<p>페이지 맵 테이블은 커널 안에(메모리 안에) 있다. 다음과 같은 프로세스를 따른다고 볼 수 있다.  </p>
<ol>
<li>프로세스의 PMT가 저장된 주소 <code>b</code>에 접근</li>
<li>PMT에서 page p의 엔트리를 찾는다. (<code>b + p * entrySize</code>)</li>
<li>찾아진 entry의 <code>residence bit</code> 검사<ol>
<li><code>residence bit == 0</code>인 경우, <code>page fault</code>라고 부른다.<br> swap device에서 해당 page를 메모리에 적재하고 PMT를 갱신 후 3-2 수행<br> 이 과정은 컨텍스트 스위칭이 발생하고, 오버해드가 크다.</li>
<li><code>residence bit == 1</code>인 경우, 해당 entry에서 <code>page frame number</code> p’를 확인</li>
</ol>
</li>
<li>p’의 가상 주소의 <code>d</code>를 사용해 실제 주소 <code>r</code>을 만든다. (<code>r = p&#39; * pageSize + d</code>)</li>
</ol>
<hr>
<p>지금까지 소개한 방법은 <code>Directed Mapping</code>이라는 이름으로 불린다. 커널 위의 매핑 테이블을 메모리에서 찾아오는 방식인데, 이 방식에서는 한 가지 문제점이 있다. 실제 주소를 얻기까지 메모리 접근을 두 번 해야한다는 것이다. 첫 번째는 <code>PMT</code>에 접근하기 위해서, 두 번째는 실제 메모리에 접근하기 위해서. 이 문제를 해결하기 위해서 <code>Associative Mapping</code>이라는 방법을 사용하는데, 간단히 말해서 <code>TLB</code>를 사용하는 방식이다.  </p>
<p><code>TLB</code>(Translation Look-aside Buffer)라는 특수한 캐시 하드웨어를 사용해, 이곳에 <code>PMT</code>를 적재하는 방식이다. <code>TLB</code>는 <code>page number</code>를 받으면, 페이지 테이블을 병렬적으로 탐색해 굉장히 빠르게 <code>page frame number</code>를 가져올 수 있다. 다만, <code>TLB</code>는 아주 비싸기 때문에, 작은 크기이다. 따라서, 큰 <code>PMT</code>를 다루기는 어렵다. 따라서, 일반적으로 <code>PMT</code>와 <code>TLB</code>를 함꼐 사용한다. <code>PMT</code>는 그대로 메모리 공간에 올려두고, <code>PMT</code> 일부만 <code>TLB</code>에 올리는 방식이다.  </p>
<p><img src="/images/2021-09-09-memory-allocation-and-mapping/07.png?style=centerme"></p>
<p>만약 찾고자 하는 Page가 <code>TLB</code>에 없다면, <code>PMT</code>에서 가져와야 한다. 이때, 이미 <code>TLB</code>가 모두 차있다면, 대체해야 하는데 이 정책 중 일반적인 것이 최근에 가장 적게 사용된 엔트리를 빼는 것이다. 이는 메모리 지역성과 유관하다.  </p>
<h2 id="Segmentation"><a href="#Segmentation" class="headerlink" title="Segmentation"></a>Segmentation</h2><p>페이징 시스템은 논리적 단위가 아닌, 크기에 따라 프로세스를 나누기 때문에, 페이징을 공유하고 보호하는 것에서 어려움이 있다. 세그멘테이션 시스템은 프로세스를 논리적 블록으로분할한다. 즉, 프로그래머가 생각하는 모양대로 메모리를 분할해 적재해준다. 따라서, 블록의 크기는 서로 다를 수 있고 페이징 시스템에서 처럼 메모리를 미리 분할할 수도 없다.  </p>
<p>이 방식은 내부 단편화가 발생할 일이 없지만, 외부 단편화는 발생할 수 있다. 또한 세그멘트를 공유하거나 보호하는 작업을 하기 쉽지만, Address Mapping이나, 메모리 관리에서 오버헤드가 비교적 크다.  </p>
<h3 id="Address-Mapping-2"><a href="#Address-Mapping-2" class="headerlink" title="Address Mapping"></a>Address Mapping</h3><p>Non-continuous Allocation 방식의 Address Mapping의  방식과 마찬가지로, 가상 주소를 다음과 같이 표현한다.  </p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V = (s, d)</span><br><span class="line">s: segment-number</span><br><span class="line">d: displacement (offset)</span><br></pre></td></tr></table></figure>
<p>페이징 시스템에서 사용한 것처럼 <code>SMT</code>(Segment Map Table)라는 매핑 테이블을 사용한다. 매커니즘도 <code>PMT</code>와 유사하다. <code>PMT</code>와 비교하자면, <code>segment length</code>와 <code>protection bits</code>가 추가되어있다.  </p>
<p><img src="/images/2021-09-09-memory-allocation-and-mapping/08.png?style=centerme"></p>
<p>위와 같은 형태라고 볼 수 있는데, 추가된 두 필드는 다음과 같은 역할을 한다.  </p>
<ul>
<li><code>segment length</code>: 세그먼트의 크기를 기록한다. 실제 주소를 찾을때, 세그먼트 사이즈를 초과해 접근하지 않도록 만들어준다.</li>
<li><code>protection bits</code>: 세그먼트(예를 들어 함수나 데이터)에 대한 프로세스의 권한을 적는다.</li>
</ul>
<blockquote>
<p>읽기: R &#x2F; 쓰기: W &#x2F; 실행: X &#x2F; 추가: A 비트가 있다고 한다. 위에서는 추가된 두 필드라고는 하지만, 실제로 페이징 시스템에도 <code>protection bits</code>는 있는 것으로 설명한다.</p>
</blockquote>
<hr>
<p>매핑을 할때는 다이렉트 매핑 과정을 거친다.  </p>
<ol>
<li><code>V = (s, d)</code>와 함께 <code>SMT</code>가 저장된 주소 <code>b</code>에 접근해 필요한 entry를 계산해낸다. (<code>b + s * entrySize*</code>)</li>
<li><code>SMT</code>의 entry에 대해 다음 단계를 순차적으로 수행한다.<ol>
<li><code>residence bit</code>가 0인 경우 (<strong>segment fault</strong>), <code>swap-device</code>로부터 해당 segment를 메모리에 적재하고, <code>SMT</code>를 갱신한다.</li>
<li><code>d</code>가 <code>segment length</code>의 길이보다 크다면, <strong>segment overflow exception</strong> 처리 모듈을 호출한다.</li>
<li><code>protection bits</code>를 확인해, 허가 되지 않은 연산인 경우 <strong>segment protection exception</strong> 처리 모듈을 호출한다.</li>
</ol>
</li>
<li>실제 주소 <code>r</code>을 찾아 명령어를 처리한다.</li>
</ol>
<blockquote>
<p>Paging System에서 처럼 TLB를 사용해서 메모리에 두 번 접근하는 오버헤드를 줄일 수 있다.  </p>
</blockquote>
<h3 id="Memory-Manangement"><a href="#Memory-Manangement" class="headerlink" title="Memory Manangement"></a>Memory Manangement</h3><p><code>VPM</code>과 유사하게, 세그먼트를 적재할 때, 그 크기에 맞춰 동적으로 메모리를 분할한 후 적재한다. 이를 관리하는 <strong>파티션 테이블</strong>이 요구된다. 아래 구성과 같이 파티션 테이블을 관리한다.  </p>
<p><img src="/images/2021-09-09-memory-allocation-and-mapping/09.png?style=centerme"></p>
<hr>
<h2 id="Hybrid-System"><a href="#Hybrid-System" class="headerlink" title="Hybrid System"></a>Hybrid System</h2><p>페이징 시스템과 세그멘테이션 시스템의 장점을 결합한 시스템이다. 프로그램을 다음과 같이 분할한다.  </p>
<ol>
<li>논리 단위의 Segment로 분할</li>
<li>각 Segment를 고정된 크기의 Page들로 분할</li>
</ol>
<p>메모리에 적재할 때는 페이지 단위로 적재하게 된다.</p>
<h3 id="Address-Mapping-3"><a href="#Address-Mapping-3" class="headerlink" title="Address Mapping"></a>Address Mapping</h3><p>가상 주소는 다음과 같은 형태로 주워진다.</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">V = (s, p, d)</span><br><span class="line">s: segment number</span><br><span class="line">p: page number</span><br><span class="line">d: offset</span><br></pre></td></tr></table></figure>
<p>매핑을 위해 <code>SMT</code>와 <code>PMT</code>를 모두 사용해야 한다. 각 <strong>프로세스마다</strong> 하나의 <code>SMT</code>가 존재하고, 하나의 <strong>세그먼트마다</strong> 하나의 <code>PMT</code>를 갖는 구조이다. <code>SMT</code> 테이블은 마지막에 실제 주소 대신, <code>PMT</code>의 베이스 주소를 알려준다. 아래는 하이브리드 시스템에서의 <code>SMT</code>이다.  </p>
<p><img src="/images/2021-09-09-memory-allocation-and-mapping/10.png?style=centerme"></p>
<p>이전 <code>SMT</code>테이블과 다른 모습은, 첫 번째로 <code>resident bit</code>가 없다는 점이다. 실제 메모리에 올라가는 것은 Page이기 때문에 <code>residence bit</code>는 불필요하다. 두 번째는, 위에서 언급한 것처럼 실제 주소를 매핑하고 있지 않고, 해당 세그먼트의 <code>PMT</code> 메모리 주소를 매핑한다.  </p>
<p><code>PMT</code>는 페이징 시스템에서 봤던 것과 동일한 모습이다.</p>
<p><img src="/images/2021-09-09-memory-allocation-and-mapping/11.png?style=centerme"></p>
<p>이런 형태의 테이블 구조로, 아래와 같이 프로세스를 나눈다.</p>
<p><img src="/images/2021-09-09-memory-allocation-and-mapping/12.png?style=centerme"></p>
<p>아래는 다이렉트 매핑 방식에서의 메모리 매핑 플로우이다.</p>
<p><img src="/images/2021-09-09-memory-allocation-and-mapping/13.png?style=centerme"></p>
<p>이런 시스템을 사용했을 때, 실제 메모리에 접근하는 것을 포함해서 <strong>세 번을</strong> 접근해야 한다. 또한, 테이블 수도 증가하므로, 메모리 소모도 비교적 커지고, 매핑 과정 자체가 길어진다.  </p>
<blockquote>
<p>이런 오버헤드가 있지만, 사용함으로써 얻는 장점이 크기 때문에 사용되는 것이라고 볼 수 있다고 한다. Page sharing, protection에 강점이 있고, 메모리 할당 및 관리에 드는 오버헤드가 작다.</p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN">https://www.youtube.com/playlist?list=PLBrGAFAIyf5rby7QylRc6JxU5lzQ9c4tN</a></li>
<li>운영체제 교과서</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>메모리 할당과 매핑</p><p><a href="https://changhoi.kim/posts/os/memory-allocation-and-mapping/">https://changhoi.kim/posts/os/memory-allocation-and-mapping/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>changhoi</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-09-09</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-09-09</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/cs/">cs</a><a class="link-muted mr-2" rel="tag" href="/tags/memory/">memory</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><div class="card"><div class="card-content"><h3 class="title is-5">관련 글</h3><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/system-design-part-1/"><img src="/images/2023-10-05-system-design-part-1/thumbnail.png" alt="대규모 시스템 디자인 Part 1 강의"></a></figure><div class="media-content"><p class="date"><time datetime="2023-10-04T15:00:00.000Z">2023-10-05</time></p><p class="title"><a href="/posts/etc/system-design-part-1/">대규모 시스템 디자인 Part 1 강의</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/network/about-http3/"><img src="/images/2023-02-04-about-http3/logo.png" alt="HTTP/3에 대하여"></a></figure><div class="media-content"><p class="date"><time datetime="2023-02-03T15:00:00.000Z">2023-02-04</time></p><p class="title"><a href="/posts/network/about-http3/">HTTP/3에 대하여</a></p><p class="categories"><a href="/categories/network/">network</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/database/rdb-scaling/"><img src="/images/2022-02-09-rdb-scaling/thumbnail.png?style=centerme" alt="RDB 스케일링"></a></figure><div class="media-content"><p class="date"><time datetime="2022-02-08T15:00:00.000Z">2022-02-09</time></p><p class="title"><a href="/posts/database/rdb-scaling/">RDB 스케일링</a></p><p class="categories"><a href="/categories/database/">database</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/network/about-nat/"><img src="/images/2021-10-07-about-nat/nat.jpg" alt="NAT에 대하여"></a></figure><div class="media-content"><p class="date"><time datetime="2021-10-06T15:00:00.000Z">2021-10-07</time></p><p class="title"><a href="/posts/network/about-nat/">NAT에 대하여</a></p><p class="categories"><a href="/categories/network/">network</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/network/about-dhcp/"><img src="/images/2021-09-23-about-dhcp/03.png" alt="DHCP에 대하여"></a></figure><div class="media-content"><p class="date"><time datetime="2021-09-22T15:00:00.000Z">2021-09-23</time></p><p class="title"><a href="/posts/network/about-dhcp/">DHCP에 대하여</a></p><p class="categories"><a href="/categories/network/">network</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/backend/https-dive/"><img src="/images/2021-08-13-https-dive/01.png" alt="HTTPS 설명하기"></a></figure><div class="media-content"><p class="date"><time datetime="2021-08-12T15:00:00.000Z">2021-08-13</time></p><p class="title"><a href="/posts/backend/https-dive/">HTTPS 설명하기</a></p><p class="categories"><a href="/categories/backend/">backend</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/shallow-knowledge-of-funtional-programming/"><img src="/images/2019-12-19-shallow-knowledge-of-functional-programming/thumbnail.png" alt="함수형 프로그래밍에 대한 얕은 지식"></a></figure><div class="media-content"><p class="date"><time datetime="2019-12-18T15:00:00.000Z">2019-12-19</time></p><p class="title"><a href="/posts/etc/shallow-knowledge-of-funtional-programming/">함수형 프로그래밍에 대한 얕은 지식</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article></div></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/network/about-dhcp/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">DHCP에 대하여</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/backend/https-dive/"><span class="level-item">HTTPS 설명하기</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">댓글</h3><div class="fb-comments" data-width="100%" data-href="https://changhoi.kim/posts/os/memory-allocation-and-mapping/" data-num-posts="5"></div><script>(function(d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return;
            js = d.createElement(s); js.id = id;
            js.src = "//connect.facebook.net/ko/sdk.js#xfbml=1&version=v12.0";
            fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars2.githubusercontent.com/u/34329147?s=400&amp;u=9d1b1dc88bc8ee5965f35b0160780264c3619eb6&amp;v=4" alt="Changhoi Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Changhoi Kim</p><p class="is-size-6 is-block">Co-Founder of Bayesians</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul, Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives/"><p class="title">75</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories/"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags/"><p class="title">47</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.linkedin.com/in/changhoi/" target="_blank" rel="external nofollow noopener noreferrer">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="LinkedIn" href="https://www.linkedin.com/in/changhoi/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/changhoi"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Email" href="mailto:changhoi0522@gmail.com"><i class="fas fa-envelope-square"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="English" href="https://jayce.kim"><i class="fas fa-language"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/backend/"><span class="level-start"><span class="level-item">backend</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/books/"><span class="level-start"><span class="level-item">books</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/database/"><span class="level-start"><span class="level-item">database</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/essay/"><span class="level-start"><span class="level-item">essay</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/etc/"><span class="level-start"><span class="level-item">etc</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/logs/"><span class="level-start"><span class="level-item">logs</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/os/"><span class="level-start"><span class="level-item">os</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/rust/"><span class="level-start"><span class="level-item">rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/serverless/"><span class="level-start"><span class="level-item">serverless</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">카탈로그</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Continuous-Memory-Allocation"><span class="level-left"><span class="level-item">1</span><span class="level-item">Continuous Memory Allocation</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Fixed-Partition-FPM-고정-분할"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Fixed Partition (FPM, 고정 분할)</span></span></a></li><li><a class="level is-mobile" href="#Variable-Partition-VPM-가변-분할"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Variable Partition (VPM, 가변 분할)</span></span></a></li><li><a class="level is-mobile" href="#메모리-배치-전략"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">메모리 배치 전략</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#최초-적합-First-fit"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">최초 적합 (First-fit)</span></span></a></li><li><a class="level is-mobile" href="#최적-적합-Best-fit"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">최적 적합 (Best-fit)</span></span></a></li><li><a class="level is-mobile" href="#최악-적합-Worst-fit"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">최악 적합 (Worst-fit)</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Non-Continuous-Memory-Allocation"><span class="level-left"><span class="level-item">2</span><span class="level-item">Non-Continuous Memory Allocation</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Address-Mapping"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Address Mapping</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Block-Mapping"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">Block Mapping</span></span></a></li></ul></li><li><a class="level is-mobile" href="#V-b-d-로-표현되면-먼저-BMT에서-b에-해당하는-열을-찾는다-해당-열에서는-블록이-메모리에-적재된-상태인지-아닌지-확인-후-적재된-상태라면-Real-Address를-받아와서-d와-함께-명령어-주소를-찾는다-적재되지-않은-상태라면-해당-블록을-메모리에-올리고-BMT를-업데이트-하고-Real-Address를-받아와-명령어-주소를-계산한다-사용자-프로그램을-여러-개의-블록으로-분할하고-swap-device에-모두-두고-실행-시-필요한-블록만-메인-메모리에-적재하는-방식이다-이-방식은-구체적인-구현이라기-보단-Non-continuous-Memory-Allocation에서-주로-사용하는-메모리-매핑-방법이다-이후-구체적으로-페이징-방식이나-세그먼테이션-방식에서-어떻게-주소를-찾아주는지-나온다"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">V = (b, d)로 표현되면, 먼저 BMT에서 b에 해당하는 열을 찾는다. 해당 열에서는 블록이 메모리에 적재된 상태인지 아닌지 확인 후, 적재된 상태라면 Real Address를 받아와서 d와 함께 명령어 주소를 찾는다. 적재되지 않은 상태라면 해당 블록을 메모리에 올리고 BMT를 업데이트 하고 Real Address를 받아와 명령어 주소를 계산한다.사용자 프로그램을 여러 개의 블록으로 분할하고, swap-device에 모두 두고, 실행 시 필요한 블록만 메인 메모리에 적재하는 방식이다.&gt; 이 방식은 구체적인 구현이라기 보단, Non-continuous Memory Allocation에서 주로 사용하는 메모리 매핑 방법이다. 이후, 구체적으로 페이징 방식이나, 세그먼테이션 방식에서 어떻게 주소를 찾아주는지 나온다.
  </span></span></a></li><li><a class="level is-mobile" href="#Paging-System"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Paging System</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Address-Mapping-1"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">Address Mapping</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Segmentation"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">Segmentation</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Address-Mapping-2"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">Address Mapping</span></span></a></li><li><a class="level is-mobile" href="#Memory-Manangement"><span class="level-left"><span class="level-item">2.4.2</span><span class="level-item">Memory Manangement</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Hybrid-System"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">Hybrid System</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Address-Mapping-3"><span class="level-left"><span class="level-item">2.5.1</span><span class="level-item">Address Mapping</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Reference"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">Reference</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.jpg" alt="Changhoi Kim" height="28"></a><p class="is-size-7"><span>&copy; 2026 changhoi</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="external nofollow noopener noreferrer" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>