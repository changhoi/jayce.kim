<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>RDB 스케일링 - CH DEVLOG</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="white"><meta name="application-name" content="CH DEV"><meta name="msapplication-TileImage" content="/img/favicon.ico"><meta name="msapplication-TileColor" content="white"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="CH DEV"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="RDB는 흔히 말하길 스케일링 (스케일 아웃) 하기 까다로운 데이터베이스라고들 한다. NoSQL이 등장하며 내세웠던 차별점 역시 이러한 부분(확장성)이 포함되어있다. 하지만 RDB가 스케일 아웃이 불가능하다는 건 절대 아니다. 많은 거대한 서비스들이 RDB를 사용하고 있고, 이 서비스들은 많은 방법으로 스케일 아웃을 구현하고 있다. 이 방법에 대해서 정리한"><meta property="og:type" content="blog"><meta property="og:title" content="RDB 스케일링"><meta property="og:url" content="https://changhoi.kim/posts/database/rdb-scaling/"><meta property="og:site_name" content="CH DEVLOG"><meta property="og:description" content="RDB는 흔히 말하길 스케일링 (스케일 아웃) 하기 까다로운 데이터베이스라고들 한다. NoSQL이 등장하며 내세웠던 차별점 역시 이러한 부분(확장성)이 포함되어있다. 하지만 RDB가 스케일 아웃이 불가능하다는 건 절대 아니다. 많은 거대한 서비스들이 RDB를 사용하고 있고, 이 서비스들은 많은 방법으로 스케일 아웃을 구현하고 있다. 이 방법에 대해서 정리한"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://changhoi.kim/images/2022-02-09-rdb-scaling/thumbnail.png?style=centerme"><meta property="article:published_time" content="2022-02-08T15:00:00.000Z"><meta property="article:modified_time" content="2022-02-08T15:00:00.000Z"><meta property="article:author" content="changhoi"><meta property="article:tag" content="cs"><meta property="article:tag" content="rdb"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://changhoi.kim/images/2022-02-09-rdb-scaling/thumbnail.png?style=centerme"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://changhoi.kim/posts/database/rdb-scaling/"},"headline":"RDB 스케일링","image":[],"datePublished":"2022-02-08T15:00:00.000Z","dateModified":"2022-02-08T15:00:00.000Z","author":{"@type":"Person","name":"changhoi"},"publisher":{"@type":"Organization","name":"CH DEVLOG","logo":{"@type":"ImageObject","url":"https://changhoi.kim/img/logo.jpg"}},"description":"RDB는 흔히 말하길 스케일링 (스케일 아웃) 하기 까다로운 데이터베이스라고들 한다. NoSQL이 등장하며 내세웠던 차별점 역시 이러한 부분(확장성)이 포함되어있다. 하지만 RDB가 스케일 아웃이 불가능하다는 건 절대 아니다. 많은 거대한 서비스들이 RDB를 사용하고 있고, 이 서비스들은 많은 방법으로 스케일 아웃을 구현하고 있다. 이 방법에 대해서 정리한"}</script><link rel="canonical" href="https://changhoi.kim/posts/database/rdb-scaling/"><link rel="alternate" href="/rss2.xml" title="CH DEVLOG" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-QBSLW6WTZW" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-QBSLW6WTZW');</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.jpg" alt="CH DEVLOG" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/images/2022-02-09-rdb-scaling/thumbnail.png?style=centerme" alt="RDB 스케일링"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2022-02-08T15:00:00.000Z" title="2022. 2. 9. 오전 12:00:00">2022-02-09</time>&nbsp;게시 됨</span><span class="level-item"><time datetime="2022-02-08T15:00:00.000Z" title="2022. 2. 9. 오전 12:00:00">2022-02-09</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/database/">database</a></span><span class="level-item">44분안에 읽기 (약 6644 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile">RDB 스케일링</h1><div class="content"><p>RDB는 흔히 말하길 스케일링 (스케일 아웃) 하기 까다로운 데이터베이스라고들 한다. NoSQL이 등장하며 내세웠던 차별점 역시 이러한 부분(확장성)이 포함되어있다. 하지만 RDB가 스케일 아웃이 불가능하다는 건 절대 아니다. 많은 거대한 서비스들이 RDB를 사용하고 있고, 이 서비스들은 많은 방법으로 스케일 아웃을 구현하고 있다. 이 방법에 대해서 정리한 글이다.</p>
<span id="more"></span>

<blockquote>
<p>우선 글 내용에서 구체적인 부분들은 <code>InnoDB</code> 스토리지 엔진의 케이스를 다루고 있다. 핵심적인 원리에 대해서는 사실 모든 RDB에서 같다고 생각된다.</p>
</blockquote>
<h2 id="거대한-테이블의-문제점"><a href="#거대한-테이블의-문제점" class="headerlink" title="거대한 테이블의 문제점"></a>거대한 테이블의 문제점</h2><p>스케일 아웃이 필요한 근본적인 이유는 무엇일지 생각해보자. In-memory 데이터베이스가 아니라면 일반적으로 RDB는 정보의 영구적인 저장을 위해 디스크에 파일을 작성하게 된다. 서비스가 성장하면서 메모리 사이즈보다 데이터 용량이 커지면 OS 레벨에서 캐시해주는 범위를 초과하면서 Disk I&#x2F;O가 급등하게 된다. 인덱스도 마찬가지이다. 인덱스 역시 파일로 관리되게 되는데, 이 인덱스 파일의 사이즈가 커지면 같은 이유로 Disk I&#x2F;O가 많아지고 속도는 Memory 접근에 비해 백만 배까지 느려진다. CRUD를 할 때 직, 간접적으로 인덱스 파일을 사용하게 되는데, 모든 동작이 이렇게 느려진다.</p>
<h2 id="해결할-수-있는-원리"><a href="#해결할-수-있는-원리" class="headerlink" title="해결할 수 있는 원리"></a>해결할 수 있는 원리</h2><p>근본적으로 해결하기 위해서는 테이블의 사이즈를 줄여줘야 한다. 이 방법으로는 두 가지를 여기서 언급하는데, 첫 번째는 일반적으로 RDB에서 제공하는 파티셔닝과 엔지니어가 직접 테이블을 분리하는 샤딩에 대해 다룬다. 간단히 말해서 파티셔닝은 하나의 RDB 안에서 테이블 하나를 내부적으로 여러 테이블로 나눠주는 것이고, 샤딩은 여러 RDB 서버를 사용해 데이터를 분할하는 방식이다.</p>
<h2 id="파티셔닝-Partitioning"><a href="#파티셔닝-Partitioning" class="headerlink" title="파티셔닝 (Partitioning)"></a>파티셔닝 (Partitioning)</h2><p>파티셔닝은 논리적으로는 하나의 테이블인데, 내부에서는 물리적으로 여러 테이블로 나눠 관리하는 방법이다. RDB마다 다를 수 있지만 일반적으로는 <code>PARTITION</code> 키워드를 통해 테이블을 분할할 수 있다. 사용하는 데이터들의 인덱스를 여러 개로 분할해서 사용할 수 있게 된다. 따라서 이전에 발생한 문제를 해결할 수도 있고, 데이터를 목정성에 맞게 나눠 관리하다가 요구에 따라 간단하게 삭제할 수도 있다.</p>
<blockquote>
<p>흔히 이 파티셔닝을 “스케일 아웃”이라고 표현하지 않는다. 일종의 기술로 대량의 데이터를 특정 기준별로 데이터베이스에 부하가 적게 생기면서 삭제할 수 있도록 하는 목적이 더 크다. 그렇지만 근본적으로 큰 테이블을 여러 테이블로 나눠주는 과정이 포함되어있어서 큰 테이블에서 발생할 수 있는 문제를 해결해줄 수 있다.</p>
</blockquote>
<h3 id="파티션-키"><a href="#파티션-키" class="headerlink" title="파티션 키"></a>파티션 키</h3><p>파티션을 만들 때, 특정 데이터가 어디에 위치하게 될지를 결정하는 키를 파티션 키라고 한다. CRUD를 할 때, 이 키를 활용해(활용할 수 있는 상황이라면) 파티션을 선택한다. 그다음 명령 동작을 수행하는 구조이다. 한 단계를 거치지만 거대한 테이블을 모두 찾아보지 않아도 된다. 이렇게 불필요한 다른 서브 테이블을 배제하는 동작을 프루닝이라고 한다.</p>
<hr>
<p>조금 구체적인 얘기인데, 파티션 키를 선택할 때 제한사항이 존재한다. 유니크 키는 논리적인 테이블 안에서 유일해야 하는 값이기 때문에 파티션 키를 통해 해당 유니크 키가 어디에 있는지 결정할 수 있어야 한다. 따라서 <strong>파티션 키는 유니크 인덱스의 일부 또는 전체를 사용해 표현해야 한다.</strong></p>
<p>예를 들어서 유니크 키가 다음과 같이 설정되어있다고 생각해보자.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PRIMARY</span> (fd1, fd2) <span class="comment">-- PRIMARY도 유니크 키</span></span><br></pre></td></tr></table></figure>

<p>파티션 키는 <code>fd1</code>을 사용하거나, <code>fd2</code>를 쓰거나, 둘 다 사용해야 한다. 그래야만 파티션 키가 유니크 값들이 무조건 같은 테이블에 있음을 확인해줄 수 있다.</p>
<h3 id="파티션에서-쿼리가-발생하는-과정"><a href="#파티션에서-쿼리가-발생하는-과정" class="headerlink" title="파티션에서 쿼리가 발생하는 과정"></a>파티션에서 쿼리가 발생하는 과정</h3><p><img src="/images/2022-02-09-rdb-scaling/partition-query.png?style=centerme"></p>
<p>우선 먼저 파티션을 구분할 수 있는 조건절이 사용되었는지 확인하고 <strong>파티션 프루닝</strong>을 시도한다. 위에서 살짝 언급했지만, 파티션 프루닝은 찾을 필요가 없는 파티션을 걸러 내는 과정이다. 그다음 일반적인 테이블을 스캔하는 과정이 발생한다.</p>
<blockquote>
<p>일반적인 테이블을 스캔하는 과정은 조건절에 인덱스가 포함된 경우 인덱스를 통해 쿼리를 하고, 그렇지 않으면 테이블 풀 스캔을 하는 과정을 말한다.</p>
</blockquote>
<p>따라서 쿼리를 하는 방법에서도 어떤 키를 기준으로 파티셔닝을 해야 할지 신중하게 결정해야 한다. 쿼리 패턴에 맞게 파티셔닝을 해야 파티셔닝을 한 효과를 최대화할 수 있다.</p>
<h3 id="파티션에서-업데이트가-발생하는-과정"><a href="#파티션에서-업데이트가-발생하는-과정" class="headerlink" title="파티션에서 업데이트가 발생하는 과정"></a>파티션에서 업데이트가 발생하는 과정</h3><p>업데이트라고 썼지만 실제로 파티셔닝이 된 데이터베이스에서는 읽기, 삭제, 삽입이 포함될 수 있는 과정이다. 업데이트 동작을 수행하기 위해서는 먼저 테이블에서 해당 데이터를 찾아야 한다. 이 과정에서 위에서 말한 쿼리 과정이 수행된다. 그다음 데이터를 수정하게 되는데, 만약 업데이트한 필드가 파티션 키와 상관없는 필드인 경우엔 값만 수정하고 끝난다. 그런데 만약 파티션 키를 수정하게 되면 해당 데이터를 재배치하는 과정이 필요하다. 즉, 데이터를 삭제 후 알맞은 파티션에 삽입하는 과정이 발생한다. 이런 동작을 하므로 파티션 키는 쉽게 변하지 않는 값으로 설정하는 것이 퍼포먼스 측면에서 좋다.</p>
<h3 id="파티션-프루닝"><a href="#파티션-프루닝" class="headerlink" title="파티션 프루닝"></a>파티션 프루닝</h3><p>지금까지 이 글을 따라오다 보면 파티션 프루닝을 몇 차례 만날 수 있다. 파티션 프루닝은 파티셔닝의 핵심이다. 이 작업은 <code>EXPLAIN</code> 명령으로 확인할 수 있다.</p>
<p><img src="/images/2022-02-09-rdb-scaling/explain-pruning.png?style=centerme"><br><small>해시 파티셔닝을 한 다음 쿼리를 <code>EXPLAIN</code>으로 확인한 모습. <code>p0</code> 파티션만 사용되고 나머지는 사용되지 않음</small></p>
<p>테이블을 분리해서 인덱스의 크기를 줄이는 것이 파티셔닝의 외적으로 드러나는 장점이지만, 사실 프루닝을 잘 할 수 있도록 쿼리를 하지 않으면 오히려 안 좋은 퍼포먼스를 발생시킨다. 따라서 무턱대고 파티션을 많이 만들어서 인덱스 사이즈를 줄이기보단 파티션 프루닝이 최적으로 발생하도록 만들고, 인덱스 서치를 한 번만 발생하도록 하는 것이 더 중요한 파티셔닝 전략이다.</p>
<h3 id="방법"><a href="#방법" class="headerlink" title="방법"></a>방법</h3><p>이 글에서는 파티셔닝 방법 4가지를 설명한다. 구체적인 내용에 대해서는 <code>MySQL</code>, 특히 <code>InnoDB</code> 스토리지 엔진을 기준으로 설명하고 있다.</p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p><img src="/images/2022-02-09-rdb-scaling/partition01.png?style=centerme"></p>
<p>범위를 기반으로 데이터를 나누기 쉬운 경우 사용할 수 있는 방법이다. 로그 데이터를 예로 들어볼 수 있다. 데이터가 시간에 따라 쌓이기 때문에 필요에 따라 월 단위나 연 단위로 테이블을 나눌 수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_logs (</span><br><span class="line"> ...</span><br><span class="line"> reg_date DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (id, reg_date)</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(reg_date)) (</span><br><span class="line"> <span class="keyword">PARTITION</span> p2017 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2018</span>),</span><br><span class="line"> <span class="keyword">PARTITION</span> p2018 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2019</span>),</span><br><span class="line"> <span class="keyword">PARTITION</span> p2019 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2020</span>),</span><br><span class="line"> <span class="keyword">PARTITION</span> p2020 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2021</span>),</span><br><span class="line"> <span class="keyword">PARTITION</span> p9999 <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>위 SQL을 보면 파티션 키로 내부 함수가 사용된 것을 볼 수 있다. 모든 내장 함수가 가능한 것은 아니고, <code>InnoDB</code>인 경우에는 이 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://dev.mysql.com/doc/refman/5.7/en/partitioning-limitations-functions.html">링크</a>에 있는 내장함수들이 가능하다. 그리고 범위 마지막 부분은 <code>MAXVALUE</code> 키워드가 사용된 것을 확인할 수 있다. 위 SQL대로면 <code>p9999</code> 파티션에 2021년도 이후 로그가 쌓이고 있다고 보면 된다. 이 때 2021년도 이후 파티션을 구성하려고 하면 단순히 <code>ADD PARTITION</code> 키워드로는 동작하지 않는다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> example_logs <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (</span><br><span class="line">    <span class="keyword">PARTITION</span> p2021 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2022</span>)</span><br><span class="line">); <span class="comment">-- ERROR</span></span><br></pre></td></tr></table></figure>

<p>맨 처음 <code>CREATE TABLE</code>을 한 <code>SQL</code>에서 알 수 있듯, 파티션으로 나눠질 때 위에서부터 차례대로 파티션 위치를 판단해 나누는 것을 알 수 있는데, <code>ADD PARTITION</code>을 하게 되면 이미 만들어진 파티션들 뒤에 파티션을 추가하기 때문에 마지막에 <code>MAXVALUE</code>를 사용하지 않는 상황이 된다. 따라서 파티션에 범위를 추가하기 위해서는 <code>REORGANIZE</code>를 사용해야 한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> example_logs REORGANIZE <span class="keyword">PARTITION</span> p9999 <span class="keyword">INTO</span> (</span><br><span class="line">    <span class="keyword">PARTITION</span> p2021 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2022</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p9999 <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>다만 <code>REORGANIZE</code> 작업은 기본적으로 그 전 파티션을 복사하는 작업이다. 따라서 데이터가 많은 경우 오래 걸릴 수도 있다. 이런 문제를 해결하기 위한 일반적인 패턴 중 하나로 <code>MAXVALUE</code> 키워드를 쓰지 않고, 미래에 사용될 범위의 파티션을 미리 만들어두는 방법이 있다. 이렇게 하면 <code>ADD PARTITION</code>을 통해 간단하게 범위를 늘릴 수 있다. 당연히 문제가 발생할 여지가 있다. 이 작업이 모종의 이유로 생략되거나 문제가 생겨 생성되지 못한 상태로 해당 테이블을 사용하게 되면 파티션에 들어가야 할 데이터의 <code>INSERT</code> 작업이 동작하지 않는다.</p>
<hr>
<p>이렇게 만들어진 파티션은 간단하게 드랍할 수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> example_logs <span class="keyword">DROP</span> <span class="keyword">PARTITION</span> p2017;</span><br></pre></td></tr></table></figure>

<p>위 코드로 2017년 로그를 삭제할 수 있다. 조건절을 통해 삭제하는 것보다 데이터베이스에 생기는 부하도 적고 빠르게 데이터를 삭제할 수 있다.</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>리스트 방식은 파티션 키가 어떤 케이스에 속하는지 직접 지정해주는 방법이다. <code>IN (...)</code> 안에 파티션으로 선택되는 리스트를 만들어주어야 한다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> posts (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    title <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">        ...</span><br><span class="line">    category_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> LIST(category_id) (</span><br><span class="line">    <span class="keyword">PARTITION</span> fleamarket <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> town <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> etc <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">3</span>, <span class="keyword">NULL</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>당연히 리스트 안의 값은 겹치면 안 되고, 만약 겹치게 되면 에러를 발생시킨다. 파티션 키의 값이 지정된 코드나 값일 때 사용할 수 있다. 위 예시에서는 포스트의 카테고리에 따라 테이블을 나눠 구성한 모습이다. 또한 키 값이 오름차순이나 내림차순의 의미가 없는 경우라면 <code>Range</code>를 사용할 수 없으므로 <code>List</code> 방법이 적합한지 생각해볼 수 있다.</p>
<p>위에서 파티션을 추가하는 방법처럼 <code>ADD</code> 키워드를 통해 파티션을 추가할 수 있고, <code>DROP PARTITION</code>을 통해 파티션을 지울 수 있다. 또 하나의 파티션을 분리 및 병합할 때는 <code>REORGANIZE PARTITION</code>을 사용할 수 있다.</p>
<blockquote>
<p><code>List</code>, <code>Range</code> 파티션의 경우 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://dev.mysql.com/doc/refman/8.0/en/partitioning-subpartitions.html"><code>Subpartition (Composite Partition)</code></a>을 구성할 수 있다.</p>
</blockquote>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>해시 함수에 의해 파티션을 결정할 수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> accounts (</span><br><span class="line">    ...</span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> HASH(id) PARTITIONS <span class="number">4</span> (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>PARTITIONS 4</code>는 4개의 파티션에 의해 분할되는 것을 의미한다. 해시 작업이라고 하는 것은 쉽게 말해서 모듈러 연산하는 작업이다. 따라서 파티션 키로 사용되는 값은 정수값을 반환해줘야 한다. 파티션 이름을 지정하려면 위에서처럼 직접 이름을 정해줄 수도 있는데, 만약 정의하지 않으면 <code>p0</code>, <code>p1</code>, … 이런 식으로 지정된다.</p>
<p>데이터를 균일하게 파티션에 분배되어야 잘 파티셔닝 된 것이라 볼 수 있는데, 해시의 경우 아주 균일하게 파티션을 분배한 것이라 볼 수 있다. 자원을 효율적으로 사용할 수 있지만, 데이터 목적이나 유형을 고려해서 파티션을 나눈 것은 아니다. 따라서 모든 데이터에 대해 용도가 비슷하고 사용 빈도도 비슷한 큰 데이터를 파티셔닝 해야할 때 사용하기 좋다. 예를 들어서 계정 정보는 오래 전에 가입했든 최근에 가입했든 지속해서 사용하는 사람들의 정보가 계속해서 사용된다.</p>
<p>하지만 이 방법으로 파티션을 분할하면 파티션을 구성을 변경하는 과정의 비용이 많이 들거나 불가능하다. 예를 들어서 하나의 파티션을 더 넣는다는 것은 해시 함수를 바꿔주는 것과 같은 의미이다. 따라서 바뀐 해시 함수로 기존 데이터를 모두 재배열 해줘야 한다. 또한 해시로 나눠진 파티션을 삭제할 일도 사실상 없다. 해시 파티션을 했을 때, 각 파티션에 어떤 데이터가 있는지에 대한 의미가 없기 떄문이다. 따라서 특정 파티션을 삭제할 이유가 없고, 실제로 삭제한려고 한다 하더라도 <code>DROP PARTITION</code>은 에러를 발생시킨다. 그리고 병합하거나 분할하는 작업도 불가능하다. 이 과정은 그냥 파티션을 늘려주거나 줄여주는 작업을 해야 한다. 예상할 수 있겠지만 파티션을 늘이고 줄이는 작업은 아주 비싼 작업이다.</p>
<blockquote>
<p><code>COALESCE PARTITION 1</code>과 같은 방법으로 파티션을 줄여줄 수 있다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> example COALESCE PARTITIONS <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>파티셔닝 이후의 유연성이 부족한 방법이기 때문에, 설계할 때 몇 개의 파티션이 적합할지 생각해보는 것이 중요하다. 하지만 해시로 사용하는 컬럼값이 조건절에 사용되면 아주 효율적으로 파티션 프루닝이 가능하다.</p>
<blockquote>
<p>유연성이 부족한 해시 파티션 문제를 해결하기 위해서 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://dev.mysql.com/doc/refman/8.0/en/partitioning-linear-hash.html"><code>Linear Hash</code></a>를 사용할 수 있다. 그러나 사용되는 특정한 알고리즘으로 인해 데이터의 분배가 덜 균등해질 수 있다.</p>
</blockquote>
<h4 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h4><p>키 파티션 방법은 해시와 거의 비슷한데 해시 함수의 모듈러를 위해 정수형 타입을 사용해야 했던 해시와는 다르게, 대부분의 타입을 파티션 키로 사용할 수 있다. 파티션 키를 <code>MD5</code>를 통해 해시값을 계산하고 그 값을 모듈러 연산해서 파티셔닝을 해주는 구조이다.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> k1 (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> KEY() <span class="comment">-- 괄호가 비어있으면, 프라이머리 키 모든 칼럼을 사용함</span></span><br><span class="line">PARTITIONS <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 프라이머리 키가 따로 없으면 유니크 키를 사용</span></span><br></pre></td></tr></table></figure>

<p>해시 파티션에 비해서 더 균등하게 나눠질 수 있다. 따라서 보다 효율적이고, 파티션 키로 사용되는 필드가 정수형이 아니어도 되기 때문에 <code>Hash</code> 방법이 사용될 수 없는 상황에서 고려해볼 수 있다.</p>
<h3 id="파티셔닝-정리"><a href="#파티셔닝-정리" class="headerlink" title="파티셔닝 정리"></a>파티셔닝 정리</h3><p>파티션 키와 파티셔닝 방법을 선택하는 기준은 데이터 접근 패턴, 어떤 유형의 데이터인지, 등 고려해볼 만한 상황이 많이 있다. 그리고 단순히 인덱스를 작게 만드는 것보다 효율적인 DML을 쓰기 위해 어떻게 설계하는 것이 좋을지도 고민해봐야 한다.</p>
<h2 id="샤딩-Sharding"><a href="#샤딩-Sharding" class="headerlink" title="샤딩 (Sharding)"></a>샤딩 (Sharding)</h2><p>단일 서버에서 효율적으로 테이블을 나눈다고 하더라도 물리적인 한계는 반드시 존재한다. 예를 들어서 데이터베이스의 디스크 크기를 늘리기 어렵다든지, 늘릴 수 있더라도 근본적인 문제 해결 방법이 아니라든지(Network 부하, 꾸준하고 급격하게 증가하는 데이터들, 서버 자체의 부하), 이러한 이유로 결국 서버를 물리적으로 여러 대를 사용해서 해결해야 한다. 이렇게 수평적인 방식으로 파티셔닝을 하는 것을 샤딩이라고 한다.</p>
<blockquote>
<p>위에서 언급한 것처럼 파티셔닝은 스케일 아웃이라고 보기 어렵다. 스케일 아웃은 결국 “수평적 확장”을 의미한다. 수평적 파티셔닝 방법이 일반적인 데이터베이스의 스케일링 방법이다. 그런데 “수평적 방식의 파티셔닝”이라는 말처럼 방법 측면에서 파티셔닝의 방법과 유사하다.</p>
</blockquote>
<hr>
<p>샤딩이라고 하는 것은 RDB의 기본적인 기능은 아니다. 즉, 개발자의 엔지니어링이 요구되는 부분이다. 어떤 데이터가 어떤 노드에 들어가 있는지 판단하는 것을 개발자가 엔지니어링을 통해 라우팅 처리 해줘야 한다. 이렇게 데이터를 저장하거나 가져올 때 적절한 노드를 찾아주는 흐름을 <strong>샤딩 로직</strong> 이라고 하는데, 이 로직은 애플리케이션 사이드에 존재할 수도 있고 스토리지 시스템의 미들웨어로 존재할 수도 있다. 애플리케이션 사이드에 이 로직이 있는 것을 <strong>Application-level 샤딩</strong>이라는 이름으로 보통 불린다. 이는 애플리케이션의 로직에서 라우팅 처리를 해준다는 것을 의미한다. ORM에서 이를 설정한다든지, 직접 데이터값에 따라 어떤 데이터베이스와 연결할지 선택하는 흐름 등을 예로 들 수 있다. 반대로 스토리지 시스템 미들웨어는 <strong>솔루션</strong>, <strong>샤딩 플랫폼</strong>, <strong>프록시</strong> 등 여러 이름으로 불리고 있다. 이 방법을 사용하면 어떤 미들웨어인지에 따라 다를 수 있지만, 일반적으로 애플리케이션에서는 데이터베이스의 라우팅 처리에 신경쓰지 않고 마치 하나의 데이터베이스와 상호작용하는 것처럼 동작하게 된다.</p>
<hr>
<p>샤딩을 하게되면 그 전처럼 RDB를 사용하지 못 할 수 있다. 여러 RDB의 특징들에 제약이 생긴다는 것을 의미한다. 대표적으로 다음과 같은 문제들이 있다.</p>
<ul>
<li>물리적으로 다른 노드의 데이터베이스와 <code>JOIN</code> 연산을 수행할 수 없는 문제</li>
<li>Auto Increment가 샤드별로 달라지는 문제</li>
<li>하나의 트랜잭션이 두 개 이상의 샤드에 접근할 수 없는 문제</li>
</ul>
<p>이런 문제가 발생할 수 있으므로 샤딩을 설계하는 과정에서 이 문제들을 고려해서 샤딩을 진행해야 한다.</p>
<h3 id="샤드-키"><a href="#샤드-키" class="headerlink" title="샤드 키"></a>샤드 키</h3><p>파티셔닝에서도 각 파티션이 어떤 데이터를 가져갈지 결정할 파티션 키가 있었던 것처럼, 분할된 노드(분리된 데이터베이스 서버)는 각각이 가져갈 데이터를 결정해야 한다. 이 기준을 샤드 키라고 부른다. 위에서 파티션 키가 변하지 않는 값으로 설정하는 것이 좋다고 했던 것과 같은 이유로 샤드 키는 변경되지 않는 값을 기준으로 설정해야 한다.</p>
<h3 id="방법-1"><a href="#방법-1" class="headerlink" title="방법"></a>방법</h3><p>샤드 키를 어떻게 설계했는지에 따라 어떻게 라우팅할지도 달라진다. 여러 방법이 있지만 여러 곳에서 소개되고 있는 두 가지 방법을 가져왔다.</p>
<h4 id="Range-Based-Sharding"><a href="#Range-Based-Sharding" class="headerlink" title="Range Based Sharding"></a>Range Based Sharding</h4><p><img src="/images/2022-02-09-rdb-scaling/range-sharding.png?style=centerme"><br><small>출처: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://techblog.woowahan.com/2687/">우아한 형제들 기술 블로그</a></small></p>
<p>특정 키의 범위에 따라 샤드에 배분해주는 방법이다. 이름에서 알 수 있듯, 위 파티셔닝 방법 중 <code>Range</code> 방식과 유사하다. 특징은 샤드를 추가하는 과정이 비교적 간단하고 라우팅도 간단하다. 다만 데이터 접근 패턴이나 범위별 데이터양을 고려한 방법은 아니기 때문에 컴퓨팅 자원을 불균형하게 소비하는 케이스가 발생할 수도 있다.</p>
<h4 id="Modulus-Key-Hash-Based-Sharding"><a href="#Modulus-Key-Hash-Based-Sharding" class="headerlink" title="Modulus (Key, Hash Based) Sharding"></a>Modulus (Key, Hash Based) Sharding</h4><p><img src="/images/2022-02-09-rdb-scaling/modular-sharding.png?style=centerme"><br><small>출처: <a target="_blank" rel="external nofollow noopener noreferrer" href="https://techblog.woowahan.com/2687/">우아한 형제들 기술 블로그</a></small></p>
<p>특정 키를 모듈러 연산으로 특정하는 방식이다. 이 방법의 다른 이름에서 알 수 있듯, 위에서 파티셔닝 방법 중 <code>Hash</code> 방식과 유사하다는 점을 알 수 있다. 특징도 <code>Hash</code> 방식의 특징과 유사하다. 데이터가 샤드에 균일하게 분산된다는 장점이 있지만, 샤드를 추가할 때 데이터를 재배열해야 하는 비용이 있다는 단점이 있다.</p>
<hr>
<h3 id="케이스-스터디"><a href="#케이스-스터디" class="headerlink" title="케이스 스터디"></a>케이스 스터디</h3><p>샤딩같은 경우는 아무래도 RDB의 자체적인 기능이 아니라서 케이스를 찾아보면 굉장히 다양한 방법으로 샤딩을 진행한 것을 볼 수 있다. 예시로 세 가지 케이스를 확인해보자.</p>
<h4 id="Notion-샤딩"><a href="#Notion-샤딩" class="headerlink" title="Notion 샤딩"></a>Notion 샤딩</h4><p>노션은 애플리케이션 레벨의 샤딩을 결정했다. <code>Vitess</code>, <code>Citus</code>와 같은 미들웨어 서비스를 알아보긴 했는데, 그 솔루션들의 동작이 불투명하다고 판단했고, 본인들 데이터를 직접 컨트롤하길 원했기 때문에 이러한 선택을 했다고 한다. 그 결정 이후에는 어떻게 데이터를 나눌지 결정하는 과정이 있었다.</p>
<ol>
<li>어떤 데이터를 샤드해야 할까? → 노션의 블록과 FK로 연관된 모든 데이터를 같이 묶어 하나의 샤드에 포함될 수 있도록 함으로써 데이터 부정확성 문제를 방지</li>
<li>어떻게 데이터를 나눠야 할까? → 워크스페이스의 ID를 기준으로 샤딩 함으로써 한 워크스페이스의 데이터들이 같은 데이터베이스 안에 들어갈 수 있도록 분할</li>
</ol>
<p>더 자세한 내용은 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.notion.so/blog/sharding-postgres-at-notion">이 링크</a>에서 확인할 수 있다.</p>
<h4 id="LINE"><a href="#LINE" class="headerlink" title="LINE"></a>LINE</h4><p>LINE Manga 서비스의 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://engineering.linecorp.com/ko/blog/line-manga-server-side/">서버 엔지니어링 스토리</a>를 보면 애플리케이션 샤딩을 한 것으로 추측된다. 몇 단계를 거쳐 샤딩을 진행했는데, 4단계에서 코드를 수정해서 샤딩을 적용한다는 얘기가 나온다. 라인 망가의 경우에는 RDB 부하 문제를 초기엔 스케일 업으로 대응했으나, 근본적인 해결책이 아니라고 판단하여 샤딩을 진행했다고 한다. 검토 과정은 생략되었는데, 새로운 컬럼을 구성하고 <code>Range Based Sharding</code>을 진행했다고 한다.</p>
<h4 id="NHN"><a href="#NHN" class="headerlink" title="NHN"></a>NHN</h4><p>NHN의 경우 게임 서버 얘기였는데, 여러 서버로 샤딩을 한 상태에서 애플리케이션 레벨의 샤딩을 했을 때 컨넥션과 관련한 문제가 생길 수 있었다고 한다. 애플리케이션 서버가 200대, DB에 컨넥션이 서버당 300개씩 각자 거는 상황이면, 하나의 DB마다 최대 6만 개의 컨넥션이 생기게 된다. 이 문제를 해결하기 위해 미들웨어를 두고 프록시를 사용하고 있다고 한다. 여기서 사용된 미들웨어는 <code>ProxySQL</code>이고, 이 솔루션을 사용하게 되면 애플리케이션 레벨에서는 하나의 데이터베이스와 통신하는 것과 같이 구성할 수 있었다고 한다. 동시 접속의 개념이 있는 게임 서버에서 컨넥션을 Demultiplexing 하는 과정에 대해 더 자세히 알아보고 싶다면 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.youtube.com/watch?v=8Eb_n7JA1yA&ab_channel=NHNCloud">이 영상</a>을 보자.</p>
<h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>사실 애플리케이션의 사용자가 증가하면서 부하를 견디는 설계를 할 때 애플리케이션이 데이터베이스와 접근할 때뿐만 아니라 고려해야 할 사항이 많이 있다. 데이터베이스의 부하를 분산하는 방법으로 미들웨어를 사용한 샤딩을 결정했다면, 이 미들웨어가 애플리케이션으로부터 오는 부하를 강하게 견디는지도 확인해봐야 한다. 이런 전반적인 이야기는 <code>Database HA</code> (<code>High Availability</code>)라는 키워드로 몇 가지 더 알아봐야 한다. 그리고 Replication과 관련된 얘기도 이 글에서는 빠져있는데, 데이터베이스를 복제해 읽기 전용 슬레이브 레플리카를 만들거나, 데이터 분석용, 백업용, 등 여러 이유로 사용할 수도 있다.</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>RDB 스케일링</p><p><a href="https://changhoi.kim/posts/database/rdb-scaling/">https://changhoi.kim/posts/database/rdb-scaling/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>changhoi</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-02-09</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-02-09</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="external nofollow noopener noreferrer" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/cs/">cs</a><a class="link-muted mr-2" rel="tag" href="/tags/rdb/">rdb</a></div><div class="a2a_kit a2a_kit_size_32 a2a_default_style"><a class="a2a_dd" target="_blank" rel="external nofollow noopener noreferrer" href="https://www.addtoany.com/share"></a><a class="a2a_button_facebook"></a><a class="a2a_button_twitter"></a><a class="a2a_button_telegram"></a><a class="a2a_button_whatsapp"></a><a class="a2a_button_reddit"></a></div><script src="https://static.addtoany.com/menu/page.js" defer></script></article></div><div class="card"><div class="card-content"><h3 class="title is-5">관련 글</h3><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/system-design-part-1/"><img src="/images/2023-10-05-system-design-part-1/thumbnail.png" alt="대규모 시스템 디자인 Part 1 강의"></a></figure><div class="media-content"><p class="date"><time datetime="2023-10-04T15:00:00.000Z">2023-10-05</time></p><p class="title"><a href="/posts/etc/system-design-part-1/">대규모 시스템 디자인 Part 1 강의</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/network/about-http3/"><img src="/images/2023-02-04-about-http3/logo.png" alt="HTTP/3에 대하여"></a></figure><div class="media-content"><p class="date"><time datetime="2023-02-03T15:00:00.000Z">2023-02-04</time></p><p class="title"><a href="/posts/network/about-http3/">HTTP/3에 대하여</a></p><p class="categories"><a href="/categories/network/">network</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/database/dynamodb-internals-2/"><img src="/images/2022-04-16-dynamodb-internals-1/thumbnail.png" alt="DynamoDB Internals (2) - DynamoDB"></a></figure><div class="media-content"><p class="date"><time datetime="2022-04-18T15:00:00.000Z">2022-04-19</time></p><p class="title"><a href="/posts/database/dynamodb-internals-2/">DynamoDB Internals (2) - DynamoDB</a></p><p class="categories"><a href="/categories/database/">database</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/database/dynamodb-internals-1/"><img src="/images/2022-04-16-dynamodb-internals-1/thumbnail.png" alt="DynamoDB Internals (1) - Dynamo"></a></figure><div class="media-content"><p class="date"><time datetime="2022-04-15T15:00:00.000Z">2022-04-16</time></p><p class="title"><a href="/posts/database/dynamodb-internals-1/">DynamoDB Internals (1) - Dynamo</a></p><p class="categories"><a href="/categories/database/">database</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/network/about-nat/"><img src="/images/2021-10-07-about-nat/nat.jpg" alt="NAT에 대하여"></a></figure><div class="media-content"><p class="date"><time datetime="2021-10-06T15:00:00.000Z">2021-10-07</time></p><p class="title"><a href="/posts/network/about-nat/">NAT에 대하여</a></p><p class="categories"><a href="/categories/network/">network</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/network/about-dhcp/"><img src="/images/2021-09-23-about-dhcp/03.png" alt="DHCP에 대하여"></a></figure><div class="media-content"><p class="date"><time datetime="2021-09-22T15:00:00.000Z">2021-09-23</time></p><p class="title"><a href="/posts/network/about-dhcp/">DHCP에 대하여</a></p><p class="categories"><a href="/categories/network/">network</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/os/memory-allocation-and-mapping/"><img src="/images/2021-09-09-memory-allocation-and-mapping/00.png" alt="메모리 할당과 매핑"></a></figure><div class="media-content"><p class="date"><time datetime="2021-09-08T15:00:00.000Z">2021-09-09</time></p><p class="title"><a href="/posts/os/memory-allocation-and-mapping/">메모리 할당과 매핑</a></p><p class="categories"><a href="/categories/os/">os</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/backend/https-dive/"><img src="/images/2021-08-13-https-dive/01.png" alt="HTTPS 설명하기"></a></figure><div class="media-content"><p class="date"><time datetime="2021-08-12T15:00:00.000Z">2021-08-13</time></p><p class="title"><a href="/posts/backend/https-dive/">HTTPS 설명하기</a></p><p class="categories"><a href="/categories/backend/">backend</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/database/dynamodb-single-table-design/"><img src="/images/2022-04-16-dynamodb-internals-1/thumbnail.png" alt="DynamoDB 설계 방법: Single Table Design"></a></figure><div class="media-content"><p class="date"><time datetime="2020-10-23T15:00:00.000Z">2020-10-24</time></p><p class="title"><a href="/posts/database/dynamodb-single-table-design/">DynamoDB 설계 방법: Single Table Design</a></p><p class="categories"><a href="/categories/database/">database</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/posts/etc/shallow-knowledge-of-funtional-programming/"><img src="/images/2019-12-19-shallow-knowledge-of-functional-programming/thumbnail.png" alt="함수형 프로그래밍에 대한 얕은 지식"></a></figure><div class="media-content"><p class="date"><time datetime="2019-12-18T15:00:00.000Z">2019-12-19</time></p><p class="title"><a href="/posts/etc/shallow-knowledge-of-funtional-programming/">함수형 프로그래밍에 대한 얕은 지식</a></p><p class="categories"><a href="/categories/etc/">etc</a></p></div></article></div></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/books/sql-cookbook/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">SQL 쿡북 간단 리뷰</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/go/about-go-range/"><span class="level-item">Go에서 range의 모든 것</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">댓글</h3><div class="fb-comments" data-width="100%" data-href="https://changhoi.kim/posts/database/rdb-scaling/" data-num-posts="5"></div><script>(function(d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return;
            js = d.createElement(s); js.id = id;
            js.src = "//connect.facebook.net/ko/sdk.js#xfbml=1&version=v12.0";
            fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars2.githubusercontent.com/u/34329147?s=400&amp;u=9d1b1dc88bc8ee5965f35b0160780264c3619eb6&amp;v=4" alt="Changhoi Kim"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Changhoi Kim</p><p class="is-size-6 is-block">Co-Founder of Bayesians</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Seoul, Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives/"><p class="title">73</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories/"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags/"><p class="title">47</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/changhoi" target="_blank" rel="external nofollow noopener noreferrer">팔로우</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="LinkedIn" href="https://www.linkedin.com/in/changhoi/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Github" href="https://github.com/changhoi"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="external nofollow noopener noreferrer" title="Email" href="mailto:changhoi0522@gmail.com"><i class="fas fa-envelope-square"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/backend/"><span class="level-start"><span class="level-item">backend</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/books/"><span class="level-start"><span class="level-item">books</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/database/"><span class="level-start"><span class="level-item">database</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/essay/"><span class="level-start"><span class="level-item">essay</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/etc/"><span class="level-start"><span class="level-item">etc</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/go/"><span class="level-start"><span class="level-item">go</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/logs/"><span class="level-start"><span class="level-item">logs</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/network/"><span class="level-start"><span class="level-item">network</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/os/"><span class="level-start"><span class="level-item">os</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/rust/"><span class="level-start"><span class="level-item">rust</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/serverless/"><span class="level-start"><span class="level-item">serverless</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">카탈로그</h3><ul class="menu-list"><li><a class="level is-mobile" href="#거대한-테이블의-문제점"><span class="level-left"><span class="level-item">1</span><span class="level-item">거대한 테이블의 문제점</span></span></a></li><li><a class="level is-mobile" href="#해결할-수-있는-원리"><span class="level-left"><span class="level-item">2</span><span class="level-item">해결할 수 있는 원리</span></span></a></li><li><a class="level is-mobile" href="#파티셔닝-Partitioning"><span class="level-left"><span class="level-item">3</span><span class="level-item">파티셔닝 (Partitioning)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#파티션-키"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">파티션 키</span></span></a></li><li><a class="level is-mobile" href="#파티션에서-쿼리가-발생하는-과정"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">파티션에서 쿼리가 발생하는 과정</span></span></a></li><li><a class="level is-mobile" href="#파티션에서-업데이트가-발생하는-과정"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">파티션에서 업데이트가 발생하는 과정</span></span></a></li><li><a class="level is-mobile" href="#파티션-프루닝"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">파티션 프루닝</span></span></a></li><li><a class="level is-mobile" href="#방법"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">방법</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Range"><span class="level-left"><span class="level-item">3.5.1</span><span class="level-item">Range</span></span></a></li><li><a class="level is-mobile" href="#List"><span class="level-left"><span class="level-item">3.5.2</span><span class="level-item">List</span></span></a></li><li><a class="level is-mobile" href="#Hash"><span class="level-left"><span class="level-item">3.5.3</span><span class="level-item">Hash</span></span></a></li><li><a class="level is-mobile" href="#Key"><span class="level-left"><span class="level-item">3.5.4</span><span class="level-item">Key</span></span></a></li></ul></li><li><a class="level is-mobile" href="#파티셔닝-정리"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">파티셔닝 정리</span></span></a></li></ul></li><li><a class="level is-mobile" href="#샤딩-Sharding"><span class="level-left"><span class="level-item">4</span><span class="level-item">샤딩 (Sharding)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#샤드-키"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">샤드 키</span></span></a></li><li><a class="level is-mobile" href="#방법-1"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">방법</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Range-Based-Sharding"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">Range Based Sharding</span></span></a></li><li><a class="level is-mobile" href="#Modulus-Key-Hash-Based-Sharding"><span class="level-left"><span class="level-item">4.2.2</span><span class="level-item">Modulus (Key, Hash Based) Sharding</span></span></a></li></ul></li><li><a class="level is-mobile" href="#케이스-스터디"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">케이스 스터디</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Notion-샤딩"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">Notion 샤딩</span></span></a></li><li><a class="level is-mobile" href="#LINE"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">LINE</span></span></a></li><li><a class="level is-mobile" href="#NHN"><span class="level-left"><span class="level-item">4.3.3</span><span class="level-item">NHN</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#마치며"><span class="level-left"><span class="level-item">5</span><span class="level-item">마치며</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.jpg" alt="CH DEVLOG" height="28"></a><p class="is-size-7"><span>&copy; 2025 changhoi</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="external nofollow noopener noreferrer">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="external nofollow noopener noreferrer" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="external nofollow noopener noreferrer" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>